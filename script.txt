//Real Soccer Variables
var throwTimeOut = 420; // 7 seconds (var is in game ticks)
var gkTimeOut = 600; // 10 seconds (var is in game ticks)
var ckTimeOut = 600; // 10 seconds (var is in game ticks)
var throwinDistance = 270; // distance players can move the ball during throw in
var mapBGColor = "86A578"; // default 718C5A
var superAdminCode = "dRSB25lp"; // !admin 505050
var allowPublicAdmin = false; // if true then !admin command is enabled

// Room System Variables
var teamRed = [];
var teamBlue = [];

function getRealSoccerMap() {
	var realSoccerMap = `{"name":"‚öΩ Real Soccer X4 üî¥","width":1300,"height":670,"spawnDistance":560,"bg":{"type":"grass","width":1150,"height":600,"kickOffRadius":180,"cornerRadius":0,"color":"`+mapBGColor+`"},"playerPhysics":{"bCoef":0.3,"invMass":0.5,"damping":0.96,"acceleration":0.12,"kickingAcceleration":0.07,"kickingDamping":0.96,"kickStrength":5.65},"ballPhysics":{"radius":9,"bCoef":0.5,"invMass":1.05,"damping":0.99,"color":"FFFFFF","cMask":["all"],"cGroup":["ball"]},"vertexes":[{"x":0,"y":675,"trait":"kickOffBarrier"},{"x":0,"y":180,"trait":"kickOffBarrier"},{"x":0,"y":-180,"trait":"kickOffBarrier"},{"x":0,"y":-675,"trait":"kickOffBarrier"},{"x":1150,"y":320,"trait":"line"},{"x":840,"y":320,"trait":"line"},{"x":1150,"y":-320,"trait":"line"},{"x":840,"y":-320,"trait":"line"},{"x":1150,"y":180,"trait":"line"},{"x":1030,"y":180,"trait":"line"},{"x":1150,"y":-180,"trait":"line"},{"x":1030,"y":-180,"trait":"line"},{"x":840,"y":-130,"trait":"line","curve":-130},{"x":840,"y":130,"trait":"line","curve":-130},{"x":-1150,"y":-320,"trait":"line"},{"x":-840,"y":-320,"trait":"line"},{"x":-1150,"y":320,"trait":"line"},{"x":-840,"y":320,"trait":"line"},{"x":-1150,"y":-175,"trait":"line"},{"x":-1030,"y":-175,"trait":"line"},{"x":-1150,"y":175,"trait":"line"},{"x":-1030,"y":175,"trait":"line"},{"x":-840,"y":130,"trait":"line","curve":-130},{"x":-840,"y":-130,"trait":"line","curve":-130},{"x":935,"y":3,"trait":"line"},{"x":935,"y":-3,"trait":"line"},{"x":-935,"y":3,"trait":"line"},{"x":-935,"y":-3,"trait":"line"},{"x":-1150,"y":570,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":-1120,"y":600,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":-1120,"y":-600,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":-1150,"y":-570,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":1120,"y":600,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":1150,"y":570,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":1150,"y":-570,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":1120,"y":-600,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"x":0,"y":180,"bCoef":0.1,"cMask":["red","blue"],"cGroup":["blueKO"],"trait":"kickOffBarrier","curve":-180},{"x":0,"y":-180,"bCoef":0.1,"cMask":["red","blue"],"cGroup":["redKO"],"trait":"kickOffBarrier","curve":180},{"x":0,"y":180,"bCoef":0.1,"cMask":["red","blue"],"cGroup":["redKO"],"trait":"kickOffBarrier","curve":180},{"x":-1030,"y":-40,"bCoef":-5.7,"cMask":["ball"],"cGroup":["c0"],"trait":"line","curve":70,"color":"576C46","vis":false},{"x":-1030,"y":40,"bCoef":-5.7,"cMask":["ball"],"cGroup":["c0"],"trait":"line","curve":70,"color":"576C46","vis":false},{"x":1030,"y":-40,"bCoef":-5.7,"cMask":["ball"],"cGroup":["c0"],"trait":"line","curve":-70,"color":"576C46","vis":false},{"x":1030,"y":40,"bCoef":-5.7,"cMask":["ball"],"cGroup":["c0"],"trait":"line","curve":-70,"color":"576C46","vis":false},{"x":1030,"y":-40,"trait":"line","color":"576C46"},{"x":1030,"y":40,"trait":"line","color":"576C46"},{"x":-1030,"y":-40,"trait":"line","color":"576C46"},{"x":-1030,"y":40,"trait":"line","color":"576C46"},{"x":0,"y":3,"trait":"line"},{"x":0,"y":-3,"trait":"line"},{"x":-1157,"y":605,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":-1157,"y":655,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":-1157,"y":-655,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":-1157,"y":-605,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":1157,"y":605,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":1157,"y":655,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":1157,"y":-655,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":1157,"y":-605,"bCoef":0,"cMask":["ball"],"trait":"ballArea"},{"x":-1300,"y":-485,"bCoef":0,"cMask":["c1"],"cGroup":["red","blue"],"color":"ec644b","vis":false},{"x":1300,"y":-485,"bCoef":0,"cMask":["c1"],"cGroup":["red","blue"],"color":"ec644b","vis":false},{"x":-1300,"y":485,"bCoef":0,"cMask":["c1"],"cGroup":["red","blue"],"color":"ec644b","vis":false},{"x":1300,"y":485,"bCoef":0,"cMask":["c1"],"cGroup":["red","blue"],"color":"ec644b","vis":false},{"x":-1295,"y":-320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":-840,"y":-320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":-840,"y":320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":-1295,"y":320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":1295,"y":-320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":840,"y":-320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":840,"y":320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":1295,"y":320,"cMask":["c0"],"cGroup":["red","blue"]},{"x":-1150,"y":-124,"bCoef":0,"cMask":["ball","red","blue"]},{"x":-1210,"y":-124,"bCoef":0,"cMask":["ball"],"bias":0,"curve":5},{"x":-1150,"y":124,"bCoef":0,"cMask":["ball","red","blue"]},{"x":-1210,"y":124,"bCoef":0,"cMask":["ball"],"bias":0,"curve":5},{"x":-1250,"y":-158,"bCoef":0,"cMask":["ball"]},{"x":-1250,"y":158,"bCoef":0,"cMask":["ball"]},{"x":1150,"y":124,"bCoef":0,"cMask":["ball","red","blue"]},{"x":1210,"y":124,"bCoef":0,"cMask":["ball"],"curve":-5},{"x":1150,"y":-124,"bCoef":0,"cMask":["ball","red","blue"]},{"x":1210,"y":-124,"bCoef":0,"cMask":["ball"],"curve":-5},{"x":1250,"y":-158,"bCoef":0,"cMask":["ball"]},{"x":1250,"y":158,"bCoef":0,"cMask":["ball"]}],"segments":[{"v0":0,"v1":1,"trait":"kickOffBarrier"},{"v0":2,"v1":3,"trait":"kickOffBarrier"},{"v0":4,"v1":5,"trait":"line","y":320},{"v0":5,"v1":7,"trait":"line","x":840},{"v0":6,"v1":7,"trait":"line","y":-320},{"v0":8,"v1":9,"trait":"line","y":180},{"v0":9,"v1":11,"trait":"line","x":1030},{"v0":10,"v1":11,"trait":"line","y":-180},{"v0":12,"v1":13,"curve":-130,"trait":"line","x":840},{"v0":14,"v1":15,"trait":"line","y":-320},{"v0":15,"v1":17,"trait":"line","x":-840},{"v0":16,"v1":17,"trait":"line","y":320},{"v0":18,"v1":19,"trait":"line","y":-175},{"v0":19,"v1":21,"trait":"line","x":-1030},{"v0":20,"v1":21,"trait":"line","y":175},{"v0":22,"v1":23,"curve":-130,"trait":"line","x":-840},{"v0":24,"v1":25,"curve":-180,"trait":"line","x":935},{"v0":26,"v1":27,"curve":-180,"trait":"line","x":-935},{"v0":24,"v1":25,"curve":180,"trait":"line","x":935},{"v0":26,"v1":27,"curve":180,"trait":"line","x":-935},{"v0":24,"v1":25,"curve":90,"trait":"line","x":935},{"v0":26,"v1":27,"curve":90,"trait":"line","x":-935},{"v0":24,"v1":25,"curve":-90,"trait":"line","x":935},{"v0":26,"v1":27,"curve":-90,"trait":"line","x":-935},{"v0":24,"v1":25,"trait":"line","x":935},{"v0":26,"v1":27,"trait":"line","x":-935},{"v0":28,"v1":29,"curve":90,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"v0":30,"v1":31,"curve":90,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"v0":32,"v1":33,"curve":90,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"v0":34,"v1":35,"curve":90,"bCoef":-2.65,"cMask":["ball"],"cGroup":["c0"],"trait":"line"},{"v0":37,"v1":36,"curve":-180,"vis":false,"bCoef":0.1,"cGroup":["blueKO"],"trait":"kickOffBarrier"},{"v0":39,"v1":40,"curve":70,"vis":false,"color":"576C46","bCoef":-5.7,"cMask":["ball"],"cGroup":["c0"],"trait":"line","x":-1030},{"v0":41,"v1":42,"curve":-70,"vis":false,"color":"576C46","bCoef":-5.7,"cMask":["ball"],"cGroup":["c0"],"trait":"line","x":1030},{"v0":37,"v1":38,"curve":180,"vis":false,"bCoef":0.1,"cMask":["red","blue"],"cGroup":["redKO"],"trait":"kickOffBarrier"},{"v0":43,"v1":44,"vis":true,"color":"576C46","trait":"line","x":1030},{"v0":45,"v1":46,"vis":true,"color":"576C46","trait":"line","x":-1030},{"v0":47,"v1":48,"curve":-180,"trait":"line","x":-935},{"v0":47,"v1":48,"curve":180,"trait":"line","x":-935},{"v0":47,"v1":48,"curve":90,"trait":"line","x":-935},{"v0":47,"v1":48,"curve":-90,"trait":"line","x":-935},{"v0":47,"v1":48,"trait":"line","x":-935},{"v0":49,"v1":50,"color":"FFFF00","bCoef":0,"cMask":["ball"],"trait":"ballArea","x":-1157},{"v0":51,"v1":52,"color":"FFFF00","bCoef":0,"cMask":["ball"],"trait":"ballArea","x":-1157},{"v0":53,"v1":54,"color":"FFFF00","bCoef":0,"cMask":["ball"],"trait":"ballArea","x":1157},{"v0":55,"v1":56,"color":"FFFF00","bCoef":0,"cMask":["ball"],"trait":"ballArea","x":1157},{"v0":57,"v1":58,"vis":false,"color":"ec644b","bCoef":0,"cMask":["c1"],"cGroup":["red","blue"],"y":-485},{"v0":59,"v1":60,"vis":false,"color":"ec644b","bCoef":0,"cMask":["c1"],"cGroup":["red","blue"],"y":485},{"v0":61,"v1":62,"vis":false,"color":"ec644b","cMask":["c0"],"cGroup":["red","blue"]},{"v0":62,"v1":63,"vis":false,"color":"ec644b","cMask":["c0"],"cGroup":["red","blue"]},{"v0":63,"v1":64,"vis":false,"color":"ec644b","cMask":["c0"],"cGroup":["red","blue"]},{"v0":65,"v1":66,"vis":false,"cMask":["c0"],"cGroup":["red","blue"]},{"v0":66,"v1":67,"vis":false,"cMask":["c0"],"cGroup":["red","blue"]},{"v0":67,"v1":68,"vis":false,"cMask":["c0"],"cGroup":["red","blue"]},{"v0":69,"v1":70,"color":"FFFFFF","bCoef":0,"cMask":["ball","red","blue"],"y":-124},{"v0":71,"v1":72,"color":"FFFFFF","bCoef":0,"cMask":["ball","red","blue"],"y":124},{"v0":72,"v1":70,"curve":5,"color":"FFFFFF","bCoef":0,"cMask":["ball","red","blue"],"bias":0},{"v0":70,"v1":73,"color":"FFFFFF","bCoef":0,"cMask":["ball"]},{"v0":72,"v1":74,"color":"FFFFFF","bCoef":0,"cMask":["ball"]},{"v0":75,"v1":76,"color":"FFFFFF","bCoef":0,"cMask":["ball","red","blue"],"y":124},{"v0":77,"v1":78,"color":"FFFFFF","bCoef":0,"cMask":["ball","red","blue"],"y":-124},{"v0":76,"v1":78,"curve":-5,"color":"FFFFFF","bCoef":0,"cMask":["ball","red","blue"]},{"v0":78,"v1":79,"color":"FFFFFF","bCoef":0,"cMask":["ball"]},{"v0":76,"v1":80,"color":"FFFFFF","bCoef":0,"cMask":["ball"]}],"goals":[{"p0":[-1162.45,124],"p1":[-1162.45,-124],"team":"red"},{"p0":[1162.45,124],"p1":[1162.45,-124],"team":"blue","radius":0,"invMass":1}],"discs":[{"radius":0,"invMass":0,"pos":[-1311,-19],"color":"ffffffff","bCoef":0,"cMask":["red"],"cGroup":["ball"]},{"radius":0,"invMass":0,"pos":[-1310,29],"color":"ffffffff","bCoef":0,"cMask":["blue"],"cGroup":["ball"]},{"radius":0,"invMass":0,"pos":[-1308,62],"color":"ffffffff","bCoef":0,"cMask":["red","blue"],"cGroup":["ball"]},{"radius":2.7,"pos":[-1150,600],"cGroup":["ball"],"trait":"cornerflag"},{"radius":2.7,"pos":[1150,-600],"cGroup":["ball"],"trait":"cornerflag"},{"radius":2.7,"pos":[1150,600],"cGroup":["ball"],"trait":"cornerflag"},{"radius":5,"invMass":0,"pos":[-1150,-124],"bCoef":0.5,"trait":"goalPost"},{"radius":5,"invMass":0,"pos":[-1150,124],"bCoef":0.5,"trait":"goalPost"},{"radius":2,"invMass":0,"pos":[-1250,-158],"color":"000000","bCoef":1,"trait":"goalPost"},{"radius":2,"invMass":0,"pos":[-1250,158],"color":"000000","bCoef":1,"trait":"goalPost"},{"radius":5,"invMass":0,"pos":[1150,-124],"bCoef":0.5,"trait":"goalPost"},{"radius":5,"invMass":0,"pos":[1150,124],"bCoef":0.5,"trait":"goalPost"},{"radius":2,"invMass":0,"pos":[1250,-158],"color":"000000","bCoef":1,"trait":"goalPost"},{"radius":2,"invMass":0,"pos":[1250,158],"color":"000000","bCoef":1,"trait":"goalPost"},{"radius":2.7,"pos":[-1150,-600],"cGroup":["ball"],"trait":"cornerflag"},{"radius":0,"pos":[-1149,-485],"cMask":["none"]},{"radius":0,"pos":[1149,-485],"cMask":["none"]},{"radius":0,"pos":[-1149,-485],"cMask":["none"]},{"radius":0,"pos":[1149,-485],"cMask":["none"]},{"radius":0,"pos":[-1149,485],"cMask":["none"]},{"radius":0,"pos":[1149,485],"cMask":["none"]},{"radius":0,"pos":[-1149,485],"cMask":["none"]},{"radius":0,"pos":[1149,485],"cMask":["none"]}],"planes":[{"normal":[0,1],"dist":-627,"bCoef":0,"cGroup":["ball"],"trait":"ballArea","_data":{"extremes":{"normal":[0,1],"dist":-627,"canvas_rect":[-1311,-675,1300,675],"a":[-1311,-627],"b":[1300,-627]}}},{"normal":[0,-1],"dist":-627,"bCoef":0,"cGroup":["ball"],"trait":"ballArea","_data":{"extremes":{"normal":[0,-1],"dist":-627,"canvas_rect":[-1311,-675,1300,675],"a":[-1311,627],"b":[1300,627]},"mirror":{}}},{"normal":[0,1],"dist":-670,"bCoef":0,"_data":{"extremes":{"normal":[0,1],"dist":-670,"canvas_rect":[-1311,-675,1300,675],"a":[-1311,-670],"b":[1300,-670]},"mirror":{}}},{"normal":[0,-1],"dist":-670,"bCoef":0,"_data":{"extremes":{"normal":[0,-1],"dist":-670,"canvas_rect":[-1311,-675,1300,675],"a":[-1311,670],"b":[1300,670]},"mirror":{}}},{"normal":[1,0],"dist":-1300,"bCoef":0,"_data":{"extremes":{"normal":[1,0],"dist":-1300,"canvas_rect":[-1311,-675,1300,675],"a":[-1300,-675],"b":[-1300,675]}}},{"normal":[-1,0],"dist":-1300,"bCoef":0.1,"_data":{"extremes":{"normal":[-1,0],"dist":-1300,"canvas_rect":[-1311,-675,1300,675],"a":[1300,-675],"b":[1300,675]}}},{"normal":[1,0],"dist":-1230,"bCoef":0,"cMask":["ball"],"cGroup":["ball"],"_data":{"extremes":{"normal":[1,0],"dist":-1230,"canvas_rect":[-1311,-675,1300,675],"a":[-1230,-675],"b":[-1230,675]}}},{"normal":[-1,0],"dist":-1230,"bCoef":0,"cMask":["ball"],"cGroup":["ball"],"_data":{"extremes":{"normal":[-1,0],"dist":-1230,"canvas_rect":[-1311,-675,1300,675],"a":[1230,-675],"b":[1230,675]}}}],"traits":{"ballArea":{"vis":false,"bCoef":0,"cMask":["ball"],"cGroup":["ball"]},"goalPost":{"radius":5,"invMass":0,"bCoef":1,"cGroup":["ball"]},"rightNet":{"radius":0,"invMass":1,"bCoef":0,"cGroup":["ball","c3"]},"leftNet":{"radius":0,"invMass":1,"bCoef":0,"cGroup":["ball","c2"]},"stanchion":{"radius":3,"invMass":0,"bCoef":3,"cMask":["none"]},"cornerflag":{"radius":3,"invMass":0,"bCoef":0.2,"color":"FFFF00","cMask":["ball"]},"reargoalNetleft":{"vis":true,"bCoef":0.1,"cMask":["ball","red","blue"],"curve":10,"color":"C7E6BD"},"reargoalNetright":{"vis":true,"bCoef":0.1,"cMask":["ball","red","blue"],"curve":-10,"color":"C7E6BD"},"sidegoalNet":{"vis":true,"bCoef":1,"cMask":["ball","red","blue"],"color":"C7E6BD"},"kickOffBarrier":{"vis":false,"bCoef":0.1,"cGroup":["redKO","blueKO"],"cMask":["red","blue"]},"line":{"vis":true,"cMask":[],"color":"C7E6BD"}},"joints":[{"d0":16,"d1":17,"strength":"rigid","color":"ec7458","length":null},{"d0":18,"d1":19,"strength":"rigid","color":"48bef9","length":null},{"d0":20,"d1":21,"strength":"rigid","color":"ec7458","length":null},{"d0":22,"d1":23,"strength":"rigid","color":"48bef9","length":null}],"redSpawnPoints":[],"blueSpawnPoints":[],"canBeStored":false}`;
	
	return realSoccerMap;
}

var roomName = "üî∞ ùó•ùó¶ùóï „Ö§‚Ä¢„Ö§ üî¥‚öΩ REAL SOCCER x4 ‚öΩüî¥";
var roomPassword = null;
var maxPlayers = 20;
var roomPublic = true;
var token = "thr1.AAAAAGf0Xa4po6gQ4CqDrg.P_ca6eA8esw";
var roomLink = "";
var gameTime = 4; //default game time if 0 is selected
var map = "RSR";
var superAdmins = [];
var ownerConns = []; // Array para armazenar conns dos donos

var room = HBInit({
	roomName: roomName,
	password: roomPassword,
	maxPlayers: maxPlayers,
	public: roomPublic,
	geo: { code: "BR", lat: -34.6374, lon: -58.4058 },
	noPlayer: true,
	token: "thr1.AAAAAGcoAsBxfoE8lh91hQ.AGCxw7QVEVg",
});


// -------------------------------------------------
// Classes
// -------------------------------------------------
class Game {
	constructor() {
		this.time = 0;
		this.paused = false;
		this.ballRadius;
		this.rsTouchTeam = 0;
		this.rsActive = true;
		this.rsReady = false;
		this.rsCorner = false;
		this.rsGoalKick = false;
		this.rsSwingTimer = 1000;
		this.rsTimer;
		this.ballOutPositionX;
		this.ballOutPositionY;
		this.throwInPosY;
		this.outStatus = "";
		this.warningCount = 0;
		this.bringThrowBack = false;
		this.extraTime = false;
		this.extraTimeCount = 0;
		this.extraTimeEnd;
		this.extraTimeAnnounced = false;
		this.lastPlayAnnounced = false;
		this.goldenGoal = false; // Controla se o jogo est√° em modo de gol de ouro
		this.boosterState;
		this.throwinKicked = false;
		this.pushedOut;
		this.lastKickerId;
		this.lastKickerName;
		this.lastKickerTeam;
		this.secondLastKickerId;
		this.secondLastKickerName;
		this.secondLastKickerTeam;
		this.redScore = 0;
		this.blueScore = 0;
	}
	
	updateLastKicker(id, name, team) {
		this.secondLastKickerId = this.lastKickerId;
		this.secondLastKickerName = this.lastKickerName;
		this.secondLastKickerTeam = this.lastKickerTeam;
		
		this.lastKickerId = id;
		this.lastKickerName = name;
		this.lastKickerTeam = team;
	}
}

// Sistema de usu√°rios
var registeredUsers = {}; // Armazena usu√°rios registrados: { conn: { name, password, lastLogin, stats } }
var loggedInUsers = {}; // Armazena usu√°rios logados: { conn: true }
var playerConn = {}; // Mapeia IDs de jogadores para conn: { id: conn }

// Sistema de estat√≠sticas
var currentGoalkeepers = { red: null, blue: null }; // IDs dos goleiros da partida atual
var goalkeeperDetectionTimer = null; // Timer para detectar goleiros
var cleanSheetEligible = { red: true, blue: true }; // Controla se os goleiros est√£o eleg√≠veis para CS

// Sistema de banimentos
var bannedPlayers = []; // Array para armazenar informa√ß√µes de jogadores banidos

// Constantes de AFK
const playerPositions = {};
const playerAFKTimer = {};
const AFK_WARNING_TIME = 4; // segundos
const AFK_KICK_TIME = 7;    // segundos
const TICK_RATE = 60;       // 60 ticks por segundo

// Constantes de cores
const COLOR_NORMAL = 0xFFFD82; // Cor padr√£o para an√∫ncios
const COLOR_ERROR = 0xe35b64;  // Cor para erros
const COLOR_SUCCESS = 0x5be38d; // Cor para sucessos
const COLOR_INFO = 0xFFFD82;   // Cor para informa√ß√µes
const COLOR_WARNING = 0xFFFD82; // Cor para avisos
const COLOR_RED = 0xED6A5A
const COLOR_BLUE = 0x5995ED

// Constantes para o sistema de rank
const RANKS = {
    BRONZE: { name: "Bronze", badge: "ü•â", minRating: 0, color: 0xCD7F32 },
    SILVER: { name: "Prata", badge: "ü•à", minRating: 100, color: 0xC0C0C0 },
    GOLD: { name: "Ouro", badge: "ü•á", minRating: 250, color: 0xFFD700 },
    DIAMOND: { name: "Diamante", badge: "üíé", minRating: 500, color: 0x4F86F7 },
    MASTER: { name: "Mestre", badge: "üèÜ", minRating: 800, color: 0xDD00FF },
    RADIANT: { name: "Radiante", badge: "üëëüí´", minRating: 1200, color: 0xFF0000 }
};

// Constantes para o sistema VIP
const VIP_TYPES = {
    NONE: { name: "Sem VIP", badge: "", rankBonus: 1.0 },
    BASIC: { name: "Premium", badge: "‚ö°", rankBonus: 1.2, pauseCooldown: 50, pausesPerCooldown: 1, queueJumpCooldown: 50 },
    PLUS: { name: "Premium+", badge: "‚ö°+", rankBonus: 1.3, pauseCooldown: 30, pausesPerCooldown: 1, queueJumpCooldown: 30 }
};

// Link do Discord
const DISCORD_LINK = "https://discord.gg/GjbmGWaQeb";

// Armazenar cooldowns de comandos VIP
const vipCooldowns = {
    // playerConn: { 
    //    lastPause: timestamp,
    //    pausesUsed: 0,
    //    pauseResetTime: timestamp,
    //    lastQueueJump: timestamp
    // }
};

// Fun√ß√£o para anunciar o Discord
function announceDiscord() {
    announce(`üì£ Entre no nosso Discord! ${DISCORD_LINK}`, null, COLOR_INFO, "bold", 1);
}

room.setCustomStadium(getRealSoccerMap());
room.setScoreLimit(2);
room.setTimeLimit(4);

room.onRoomLink = function(url) {
	roomLink = url;
	console.log(roomLink);
    
    // Configura o an√∫ncio autom√°tico do Discord a cada 10 minutos
    setInterval(announceDiscord, 10 * 60 * 1000);
}

room.onStadiumChange = function(newStadiumName, byPlayer) {
	if (byPlayer != null) {
		map = "custom";
	}
	else {
		map = "RSR";
	}
}

room.onPlayerJoin = function(player) {	
    playerPositions[player.id] = null;
    playerAFKTimer[player.id] = 0;
	console.log(player.name + " joined the room");
	
	// Registra o conn do jogador
	playerConn[player.id] = player.conn;
	
	// Verificar se √© um dono pelo conn
	if (ownerConns.includes(player.conn)) {
		// Dar admin ao dono automaticamente
		room.setPlayerAdmin(player.id, true);
		if (superAdmins.indexOf(player.id) === -1) {
			superAdmins.push(player.id);
		}
		announce("üëë O dono " + player.name + " entrou na sala", null, COLOR_NORMAL, "bold", 2);
	}
	
	// Verifica se o nick j√° est√° registrado por outro usu√°rio
	let nickJaRegistrado = false;
	let donoDoNick = "";
	
	for (let conn in registeredUsers) {
		// Se for o mesmo nick mas conn diferente
		if (registeredUsers[conn].name.toLowerCase() === player.name.toLowerCase() && conn !== player.conn) {
			nickJaRegistrado = true;
			donoDoNick = registeredUsers[conn].name;
			break;
		}
	}
	
	// Se o nick j√° estiver registrado por outro usu√°rio, expulsa o jogador
	if (nickJaRegistrado) {
		room.kickPlayer(player.id, "Este nick j√° est√° registrado por outro jogador. Escolha outro nick.", false);
		return;
	}
	
	// Verifica se o jogador j√° est√° registrado
	if (registeredUsers[player.conn]) {
		whisper("üëã Bem-vindo de volta, " + player.name + "! Use !login [senha] para fazer login.", player.id, COLOR_INFO, "bold", 2);
		
		// Tenta fazer login autom√°tico
		if (registeredUsers[player.conn]) {
			// Atualiza o nome caso tenha mudado
			registeredUsers[player.conn].name = player.name;
			registeredUsers[player.conn].lastLogin = Date.now();
			
			// Loga o usu√°rio automaticamente
			loggedInUsers[player.conn] = true;
			
			whisper("‚úÖ Login realizado automaticamente!", player.id, COLOR_SUCCESS, "bold", 1);
		}
	} else {
		whisper("üëã Ea√≠ " + player.name + " bem-vindo ao Real Soccer x4 da RSB!", player.id, COLOR_INFO, "bold", 0);
		whisper("‚öΩ Jogue com seus amigos, sala brasileira e argentina!", player.id, COLOR_INFO, "bold", 0);
		whisper("üìù Registre-se usando !register [senha]", player.id, COLOR_INFO, "bold", 0);
	}
	
	room.startGame();
	
	// Verifica se temos espa√ßo para mais jogadores
	if (teamRed.length + teamBlue.length < 8) {
        // Verifica qual time precisa de jogadores
        if (teamRed.length < teamBlue.length) {
            // Time Red tem menos jogadores, adiciona nele
            room.setPlayerTeam(player.id, 1); // Red
            teamRed.push(player.id);
        } else if (teamBlue.length < teamRed.length) {
            // Time Blue tem menos jogadores, adiciona nele
            room.setPlayerTeam(player.id, 2); // Blue
            teamBlue.push(player.id);
        } else {
            // Os times est√£o equilibrados, prioriza Red por padr√£o
            room.setPlayerTeam(player.id, 1); // Red
            teamRed.push(player.id);
        }
    } else {
        // Times cheios, vai para spectator
        room.setPlayerTeam(player.id, 0); // Spectator
    }

    if (teamRed.length > 0 && teamBlue.length > 0) {
        room.startGame();
    }
}

room.onPlayerLeave = function(player) {
	delete playerPositions[player.id];
	delete playerAFKTimer[player.id];
	teamRed = teamRed.filter(id => id !== player.id);
    teamBlue = teamBlue.filter(id => id !== player.id);
	console.log(player.name + " left the room");
	
	// Remove o mapeamento do conn
	delete playerConn[player.id];
	
	// Se o jogador estava logado, remove do registro de logados
	if (player.conn && loggedInUsers[player.conn]) {
		delete loggedInUsers[player.conn];
	}
}

room.onPlayerAdminChange = function(changedPlayer, byPlayer) {
	if (byPlayer != null) {
		if (changedPlayer.id != byPlayer.id) {
			if (superAdmins.indexOf(changedPlayer.id) > -1) {
				room.kickPlayer(byPlayer.id, "Voc√™ n√£o pode remover um administrador", false);
				room.setPlayerAdmin(changedPlayer.id, true);
			}
		}
		else {
			if (changedPlayer.admin == false) {
				let index = superAdmins.indexOf(changedPlayer.id);
				if (index > -1) {
				  superAdmins.splice(index, 1);
				}
			}
		}
	}
}

room.onGameStart = function(byPlayer) {
	if (map == "RSR") {
		// Reinicia os goleiros e elegibilidade de CS
		currentGoalkeepers = { red: null, blue: null };
		cleanSheetEligible = { red: true, blue: true };
		
		if (byPlayer == null) {
			game = new Game();	
		}
		else {
			if (room.getScores().timeLimit != 0) {
				gameTime = room.getScores().timeLimit / 60;
			}
			else {
				gameTime = 10;
			}
			room.stopGame();
			room.setTimeLimit(0);			
			room.startGame();
		}
		
		// Informa√ß√£o sobre detec√ß√£o de goleiros
		announce("üß§ Detectando os goleiros em 10 segundos... Goleiros, posicionem-se!", null, COLOR_INFO, "bold");
		
		// Inicia o timer para detectar goleiros
		if (goalkeeperDetectionTimer) {
			clearTimeout(goalkeeperDetectionTimer);
		}
		
		// Sistema de m√∫ltiplas tentativas para detectar goleiros
		let detectionAttempts = 0;
		const maxDetectionAttempts = 3;
		
		function attemptGoalkeeperDetection() {
			detectionAttempts++;
			console.log(`Tentativa ${detectionAttempts} de detec√ß√£o de goleiros`);
			
			let players = room.getPlayerList();
			let redPlayers = players.filter(p => p.team === 1);
			let bluePlayers = players.filter(p => p.team === 2);
			
			// Se n√£o houver jogadores suficientes, aguarda
			if (redPlayers.length < 2 || bluePlayers.length < 2) {
				if (detectionAttempts < maxDetectionAttempts) {
					setTimeout(attemptGoalkeeperDetection, 5000);
				} else {
					announce("üì£ CS n√£o ser√° contabilizado pois n√£o h√° jogadores suficientes", null, COLOR_ERROR, "bold");
				}
				return;
			}
			
			// Detecta os goleiros com base na posi√ß√£o atual (o mais atr√°s)
			let redGK = null;
			let blueGK = null;
			let minRedX = Infinity;
			let maxBlueX = -Infinity;
			
			for (let player of redPlayers) {
				if (player.position && player.position.x < minRedX) {
					minRedX = player.position.x;
					redGK = player;
				}
			}
			
			for (let player of bluePlayers) {
				if (player.position && player.position.x > maxBlueX) {
					maxBlueX = player.position.x;
					blueGK = player;
				}
			}
			
			// Se ambos os goleiros foram detectados, registra-os
			if (redGK && blueGK) {
				// Atualiza os goleiros
				currentGoalkeepers.red = redGK.id;
				let connRed = playerConn[redGK.id];
				if (connRed && registeredUsers[connRed]) {
					registeredUsers[connRed].stats.isGoalkeeper = true;
				}
				
				currentGoalkeepers.blue = blueGK.id;
				let connBlue = playerConn[blueGK.id];
				if (connBlue && registeredUsers[connBlue]) {
					registeredUsers[connBlue].stats.isGoalkeeper = true;
				}
				
				// Anuncia os goleiros
				announce("üß§ Goleiro do time üî¥ | " + redGK.name + " | Defenda seu gol!", null, COLOR_RED, "bold", 2);
				announce("üß§ Goleiro do time üîµ | " + blueGK.name + " | Defenda seu gol!", null, COLOR_BLUE, "bold", 2);
				
				console.log(`Goleiros detectados: Red=${redGK.name}, Blue=${blueGK.name}`);
				return;
			}
		}
		
		// Primeira tentativa ap√≥s 10 segundos para dar tempo dos jogadores se posicionarem
		goalkeeperDetectionTimer = setTimeout(attemptGoalkeeperDetection, 10000);
	}
}

// Fun√ß√£o para atualizar estat√≠sticas ao final do jogo
function updatePlayerStats() {
    console.log("Atualizando estat√≠sticas de jogadores...");
    
    // Obt√©m jogadores dos times
    let players = room.getPlayerList();
    let redPlayers = players.filter(p => p.team === 1);
    let bluePlayers = players.filter(p => p.team === 2);
    
    // Determina o time vencedor
    let winningTeam = game.redScore > game.blueScore ? 1 : 2;
    let losingTeam = winningTeam === 1 ? 2 : 1;
    
    // An√∫ncio sobre atualiza√ß√µes de estat√≠sticas
    announce("üìä Atualizando estat√≠sticas dos jogadores...", null, COLOR_SUCCESS, "bold");
    
    // Contadores para log
    let playersUpdated = 0;
    let playersSkipped = 0;
    
    // Todos os jogadores (tanto os em jogo quanto os que possam ter sa√≠do)
    let allRedAndBluePlayers = [...redPlayers, ...bluePlayers];
    
    // Se temos muito poucos jogadores, podemos ter perdido alguns que sa√≠ram recentemente
    if (allRedAndBluePlayers.length < 2) {
        console.log("AVISO: Poucos jogadores para atualizar estat√≠sticas. Alguns podem ter sa√≠do.");
    }
    
    console.log(`Atualizando estat√≠sticas para ${allRedAndBluePlayers.length} jogadores`);
    
    // Atualiza estat√≠sticas para cada jogador
    for (let player of allRedAndBluePlayers) {
        let conn = playerConn[player.id];
        if (!conn || !registeredUsers[conn]) {
            console.log(`Jogador ${player.name} n√£o tem conn v√°lido ou n√£o est√° registrado`);
            playersSkipped++;
            continue;
        }
        
        console.log(`Atualizando estat√≠sticas para ${player.name}`);
        
        // Incrementa jogos jogados
        registeredUsers[conn].stats.games++;
        
        // Registra vit√≥ria ou derrota
        if (player.team === winningTeam) {
            registeredUsers[conn].stats.wins++;
            console.log(`${player.name} ganhou - wins: ${registeredUsers[conn].stats.wins}`);
        } else if (player.team === losingTeam) {
            registeredUsers[conn].stats.losses++;
            console.log(`${player.name} perdeu - losses: ${registeredUsers[conn].stats.losses}`);
        }
        
        // Verifica clean sheet para goleiros
        if (player.team === 1 && player.id === currentGoalkeepers.red && cleanSheetEligible.red) {
            if (game.blueScore === 0) {
                registeredUsers[conn].stats.cleanSheets++;
                announce("üß§ Clean Sheet para " + player.name + "! | Defesa perfeita!", null, COLOR_SUCCESS, "bold");
                console.log(`${player.name} conseguiu um Clean Sheet!`);
            }
        } else if (player.team === 2 && player.id === currentGoalkeepers.blue && cleanSheetEligible.blue) {
            if (game.redScore === 0) {
                registeredUsers[conn].stats.cleanSheets++;
                announce("üß§ Clean Sheet para " + player.name + "! | Defesa perfeita!", null, COLOR_SUCCESS, "bold");
                console.log(`${player.name} conseguiu um Clean Sheet!`);
            }
        }
        
        // Resetamos a flag de goleiro no final do jogo
        registeredUsers[conn].stats.isGoalkeeper = false;
        
        // Adiciona refer√™ncia de conn para verifica√ß√£o de VIP
        registeredUsers[conn].stats._conn = conn;
        
        // Log das estat√≠sticas atualizadas
        console.log(`Estat√≠sticas de ${player.name} ap√≥s atualiza√ß√£o: Jogos=${registeredUsers[conn].stats.games}, Vit√≥rias=${registeredUsers[conn].stats.wins}, Derrotas=${registeredUsers[conn].stats.losses}, CS=${registeredUsers[conn].stats.cleanSheets}`);
        
        playersUpdated++;
    }
    
    console.log(`Atualiza√ß√£o de estat√≠sticas conclu√≠da: ${playersUpdated} jogadores atualizados, ${playersSkipped} ignorados`);
    announce(`‚úÖ Estat√≠sticas atualizadas para ${playersUpdated} jogadores`, null, COLOR_SUCCESS, "bold");
}

room.onGameStop = function(byPlayer) {
	if (map == "RSR") {
		console.log("onGameStop: Verificando condi√ß√µes para atualizar estat√≠sticas");
		
		if (byPlayer != null) {
			room.setTimeLimit(gameTime);
		}
	
		// Garante que temos um jogo v√°lido para atualizar estat√≠sticas
		if (game && game.redScore !== undefined && game.blueScore !== undefined) {
			console.log(`onGameStop: Pontua√ß√£o final - Red ${game.redScore} x ${game.blueScore} Blue`);
			
			// Atualiza estat√≠sticas dos jogadores
			updatePlayerStats();
			
			// Determina os times vencedor e perdedor
			let winningTeam = game.redScore > game.blueScore ? 1 : 2;
			let losingTeam = winningTeam === 1 ? 2 : 1;
			
			// Determinando o resultado do jogo
			let resultMsg = `üèÜ FIM DE JOGO | üî¥ ${game.redScore} - ${game.blueScore} üîµ`;
			announce(resultMsg, null, COLOR_WARNING, "bold", 2);
			
			// Move players according to the score
			// Winning team goes to red, losing team goes to spectators
			let players = room.getPlayerList();
			players.forEach(player => {
				if (player.team === winningTeam) {
					room.setPlayerTeam(player.id, 1); // Red
				} else if (player.team === losingTeam) {
					room.setPlayerTeam(player.id, 0); // Spectators
				}
			});
			
			// Wait briefly for team assignments to take effect
			setTimeout(() => {
				// After reorganizing, recheck the team counts
				players = room.getPlayerList();
				let spectators = players.filter(player => player.team === 0);
				
				// Now start the player selection process
				startPlayerSelection();
			}, 1000);
		} else {
			console.log("onGameStop: Jogo inv√°lido para atualizar estat√≠sticas");
			room.startGame();
		}
		
		// Function to handle player selection
		function startPlayerSelection() {
			// Refresh player lists
			players = room.getPlayerList();
			let spectators = players.filter(player => player.team === 0);
			
			// Verify we have enough players total (at least 9)
			if (players.length < 9) {
				// Not enough players, move all spectators to blue and start
				announce("‚ö†Ô∏è Jogadores insuficientes para o pick! Iniciando jogo normal...", null, COLOR_WARNING, "bold", 1);
				spectators.forEach(spec => {
					room.setPlayerTeam(spec.id, 2); // Move to blue team
				});
				room.startGame();
				return;
			}
			
			// Move the first spectator to blue team
			if (spectators.length > 0) {
				let selector = spectators[0];
				room.setPlayerTeam(selector.id, 2);
				
				// After moving first spectator, refresh the list
				spectators = room.getPlayerList().filter(player => player.team === 0);
				
				// If there are no more spectators to select, just start the game
				if (spectators.length === 0) {
					announce("üîÑ N√£o h√° mais espectadores dispon√≠veis. Iniciando jogo!", null, COLOR_WARNING, "bold", 1);
					room.startGame();
					return;
				}
				
				// Verify we still have enough players total
				if (room.getPlayerList().length < 9) {
					// Not enough players after kick, cancel pick
					announce("‚ö†Ô∏è Jogadores insuficientes para o pick! Iniciando jogo normal...", null, COLOR_WARNING, "bold", 1);
					// Move remaining spectators to blue
					spectators.forEach(spec => {
							room.setPlayerTeam(spec.id, 2);
					});
					room.startGame();
					return;
				}
				
				// If there are fewer than 3 spectators, adjust the required selection count
				let requiredSelections = Math.min(spectators.length, 3);
				
				// Display available spectators only to the selector
				let specList = "üî¢ Escolha at√© " + requiredSelections + " jogadores digitando o n√∫mero:";
				spectators.forEach((spec, index) => {
					specList += ` ${index + 1}. ${spec.name}`;
				});
				
				// Announce privately to the selector
				whisper(specList, selector.id, COLOR_INFO, "bold", 1);
				announce("üëâ " + selector.name + " est√° escolhendo jogadores para o time azul!", null, COLOR_INFO, "bold", 1);
				
				let selectionCount = 0;
				let selectionTimer;
				
				// Original onPlayerChat function backup
				const originalChat = room.onPlayerChat;
				
				// Setup selection timer
				startSelectionTimer();
				
				function selectPlayer(index) {
					// Check if we still have enough players
					if (room.getPlayerList().length < 9) {
						// Not enough players after kick, cancel pick
						announce("‚ö†Ô∏è Jogadores insuficientes para o pick! Iniciando jogo normal...", null, COLOR_WARNING, "bold", 1);
						clearTimeout(selectionTimer);
						room.onPlayerChat = originalChat;
						
						// Move all remaining spectators to blue
						let remainingSpectators = room.getPlayerList().filter(p => p.team === 0);
						remainingSpectators.forEach(spec => {
							room.setPlayerTeam(spec.id, 2);
						});
						
						room.startGame();
						return;
					}
				
					// Get updated spectator list
					let currentSpectators = room.getPlayerList().filter(player => player.team === 0);
					
					if (index < 0 || index >= currentSpectators.length) {
						whisper("‚ùå N√∫mero inv√°lido. Escolha entre 1 e " + currentSpectators.length, selector.id, COLOR_ERROR, "bold", 2);
						return;
					}
					
					let selectedId = currentSpectators[index].id;
					let selectedName = currentSpectators[index].name;
					room.setPlayerTeam(selectedId, 2);
					announce("‚úÖ " + selectedName + " foi selecionado para o time azul!", null, COLOR_SUCCESS, "bold", 1);
					
					selectionCount++;
					clearTimeout(selectionTimer);
					
					// Check if we've reached the required selection count or if there are no more spectators
					currentSpectators = room.getPlayerList().filter(player => player.team === 0);
					if (selectionCount < requiredSelections && currentSpectators.length > 0) {
						// Verify we still have enough players total
						if (room.getPlayerList().length < 9) {
							// Not enough players after kick, cancel pick
							announce("‚ö†Ô∏è Jogadores insuficientes para o pick! Iniciando jogo normal...", null, COLOR_WARNING, "bold", 1);
							room.onPlayerChat = originalChat;
							
							// Move all remaining spectators to blue
							currentSpectators.forEach(spec => {
								room.setPlayerTeam(spec.id, 2);
							});
							
							room.startGame();
							return;
						}
					
						// Update the list of available spectators
						specList = "üî¢ Escolha mais um jogador:";
						currentSpectators.forEach((spec, i) => {
							specList += ` ${i + 1}. ${spec.name}`;
						});
						whisper(specList, selector.id, COLOR_INFO, "bold", 1);
						whisper("‚è±Ô∏è Voc√™ tem 10 segundos para escolher.", selector.id, COLOR_WARNING, "bold", 0);
						startSelectionTimer();
					} else {
						announce("üéÆ Sele√ß√£o conclu√≠da. Iniciando o jogo!", null, COLOR_SUCCESS, "bold", 1);
						room.onPlayerChat = originalChat; // Restore original chat handler
						room.startGame();
					}
				}
				
				function startSelectionTimer() {
					selectionTimer = setTimeout(() => {
						// Check if we still have enough players
						if (room.getPlayerList().length < 9) {
							// Someone left during timeout, cancel pick
							announce("‚ö†Ô∏è Um jogador saiu da sala! Cancelando pick...", null, COLOR_WARNING, "bold", 1);
							room.onPlayerChat = originalChat;
							
							// Move all remaining spectators to blue
							let remainingSpectators = room.getPlayerList().filter(p => p.team === 0);
							remainingSpectators.forEach(spec => {
								room.setPlayerTeam(spec.id, 2);
							});
							
							room.startGame();
							return;
						}
					
						announce("‚è∞ Tempo esgotado para sele√ß√£o!", null, COLOR_ERROR, "bold", 2);
						room.kickPlayer(selector.id, "Tempo esgotado para sele√ß√£o", false);
						
						// Verify we still have enough players after kick
						if (room.getPlayerList().length < 9) {
							// Not enough players after kick, cancel pick
							announce("‚ö†Ô∏è Jogadores insuficientes para o pick! Iniciando jogo normal...", null, COLOR_WARNING, "bold", 1);
							
							// Move all remaining spectators to blue
							let remainingSpectators = room.getPlayerList().filter(p => p.team === 0);
							remainingSpectators.forEach(spec => {
								room.setPlayerTeam(spec.id, 2);
							});
							
							room.onPlayerChat = originalChat;
							room.startGame();
							return;
						}
						
						// Get new first spectator
						let newSpectators = room.getPlayerList().filter(player => player.team === 0);
						if (newSpectators.length > 0) {
							room.setPlayerTeam(newSpectators[0].id, 2);
							selector = newSpectators[0];
							announce("üëâ Novo seletor: " + selector.name, null, COLOR_INFO, "bold", 1);
							
							// Display available spectators to new selector
							currentSpectators = room.getPlayerList().filter(player => player.team === 0);
							if (currentSpectators.length > 0) {
								specList = "üî¢ Escolha at√© " + requiredSelections + " jogadores digitando o n√∫mero:";
								currentSpectators.forEach((spec, i) => {
									specList += ` ${i + 1}. ${spec.name}`;
								});
								whisper(specList, selector.id, COLOR_INFO, "bold", 1);
								whisper(specList, selector.id, 0x00BFFF, "bold", 1);
								whisper("‚è±Ô∏è Voc√™ tem 10 segundos para escolher.", selector.id, COLOR_WARNING, "bold", 0);
							}
							
							startSelectionTimer();
						} else {
							announce("üîÑ N√£o h√° mais espectadores dispon√≠veis. Iniciando jogo!", null, COLOR_WARNING, "bold", 1);
							room.onPlayerChat = originalChat;
							room.startGame();
						}
					}, 10000);
				}
				
				// Override chat handler for player selection
				room.onPlayerChat = function(player, message) {
					if (player.id === selector.id) {
						let index = parseInt(message);
						if (!isNaN(index) && index > 0) {
							selectPlayer(index - 1); // Convert to 0-based index
							return false;
						}
					}
					
					// Process other chat commands
					if (originalChat) {
						return originalChat(player, message);
					}
					return true;
				};
			} else {
				// No spectators at all
				announce("üîÑ N√£o h√° espectadores dispon√≠veis. Iniciando jogo normalmente.", null, COLOR_WARNING, "bold", 1);
				room.startGame();
			}
		}
	}
}

room.onPlayerBallKick = function(player) {	
	if (map == "RSR") {
		game.rsTouchTeam = player.team;
		game.updateLastKicker(player.id, player.name, player.team);
		
		if (game.rsReady == true) {
			var players = room.getPlayerList().filter((player) => player.team != 0);
			players.forEach(function(player) {			
				if (room.getPlayerDiscProperties(player.id).invMass.toFixed(1) != 0.3) {
					room.setPlayerDiscProperties(player.id, {invMass: 0.3});
				}
			});
		}
			
		if (game.rsActive == false && game.rsReady == true && (game.rsCorner == true || game.rsGoalKick == true)) { // make game active on kick from CK/GK
			game.boosterState = true;
			
			game.rsActive = true;
			game.rsReady = false;
			room.setDiscProperties(1, {x: 2000, y: 2000 });
			room.setDiscProperties(2, {x: 2000, y: 2000 });
			room.setDiscProperties(0, {color: "0xffffff"});
			game.rsTimer = 1000000;
			game.warningCount++;	
			
			// set gravity for real soccer corners/goalkicks
			if (game.rsCorner == true) {
				if (room.getDiscProperties(0).y < 0) { //top corner
					room.setDiscProperties(0, {xgravity: room.getPlayerDiscProperties(player.id).xspeed/35*-1, ygravity: 0.05});
					//room.setDiscProperties(0, {xgravity: -0.08, ygravity: 0.05});
				}
				else { //bottom corner
					room.setDiscProperties(0, {xgravity: room.getPlayerDiscProperties(player.id).xspeed/35*-1, ygravity: -0.05});
					//room.setDiscProperties(0, {xgravity: -0.08, ygravity: -0.05});
				}
			}	
			if (game.rsGoalKick == true) {			
				room.setDiscProperties(0, {xgravity: 0, ygravity: room.getPlayerDiscProperties(player.id).yspeed/40*-1});		
			}
			
			game.rsCorner = false;
			game.rsGoalKick = false;
			game.outStatus = "";		
		}		

		if (game.outStatus == "redThrow" || game.outStatus == "blueThrow") {
			game.throwinKicked = true;
		}
	}
}

room.onPlayerKicked = function(kickedPlayer, reason, ban, byPlayer) {	
	if (superAdmins.indexOf(kickedPlayer.id) > -1 && byPlayer != null) {
		room.kickPlayer(byPlayer.id, "Voc√™ n√£o pode kickar ou banir um administrador", false);
		room.clearBans();
	}
	
	// Se for um banimento, armazena as informa√ß√µes
	if (ban && byPlayer != null) {
		// Armazena informa√ß√µes do jogador banido
		bannedPlayers.push({
			id: kickedPlayer.id,
			name: kickedPlayer.name,
			reason: reason || "Sem motivo especificado",
			date: new Date(),
			byName: byPlayer.name,
			byId: byPlayer.id,
			ip: kickedPlayer.conn // Armazena o conn para identifica√ß√£o
		});
		
		console.log("Jogador banido: " + kickedPlayer.name + " por " + byPlayer.name);
	}
}

room.onPlayerChat = function(player, message) {
    console.log(player.name + ": " + message);
    
    // Verifica status de login do jogador
    let conn = playerConn[player.id];
    let isLoggedIn = conn && loggedInUsers[conn] ? true : false;
    let isRegistered = conn && registeredUsers[conn] ? true : false;
    
    // Verifica se o jogador tem estilo personalizado (apenas VIPs)
    let customStyle = null;
    let customColor = null;
    
    if (isLoggedIn && registeredUsers[conn].vip) {
        customStyle = registeredUsers[conn].chatStyle || "bold";
        customColor = registeredUsers[conn].chatColor || 0xFFFFFF;
    }
    
    // Se n√£o for um comando, formata a mensagem de acordo com o status de login
    if (!message.startsWith("!") && !message.startsWith("t ") && !message.startsWith("@@")) {
        // Formata a mensagem de acordo com o status do jogador
        let formattedMessage;
        
        if (isLoggedIn) {
            // Determina o rank do jogador
            let playerRank = RANKS.BRONZE; // Padr√£o para jogadores sem estat√≠sticas
            if (registeredUsers[conn] && registeredUsers[conn].stats) {
                playerRank = getPlayerRank(registeredUsers[conn].stats);
            }
            
            // Obt√©m o status VIP
            let vipStatus = VIP_TYPES.NONE;
            if (registeredUsers[conn].vip) {
                vipStatus = registeredUsers[conn].vip === "plus" ? VIP_TYPES.PLUS : VIP_TYPES.BASIC;
            }
            
            let vipBadge = vipStatus.badge ? ` [${vipStatus.badge}]` : "";
            
            // Verifique se √© o dono (tem admin e est√° na lista de superAdmins)
            if (player.admin && superAdmins.indexOf(player.id) !== -1) {
                // Dono logado: [‚úÖ] [üëë] [ü•â] [‚ö°] nick: mensagem
                formattedMessage = "[‚úÖ] [üëë] [" + playerRank.badge + "]" + vipBadge + " " + player.name + ": " + message;
                room.sendAnnouncement(formattedMessage, null, customColor || 0xFFFFFF, customStyle || "bold", 1);
            } else {
                // Jogador logado: [‚úÖ] [ü•â] [‚ö°] nick: mensagem
                formattedMessage = "[‚úÖ] [" + playerRank.badge + "]" + vipBadge + " " + player.name + ": " + message;
                room.sendAnnouncement(formattedMessage, null, customColor || 0xFFFFFF, customStyle || "bold", 1);
            }
        } else if (isRegistered) {
            // Jogador registrado tamb√©m mostra rank
            let playerRank = RANKS.BRONZE;
            if (registeredUsers[conn] && registeredUsers[conn].stats) {
                playerRank = getPlayerRank(registeredUsers[conn].stats);
            }
            
            // Obt√©m o status VIP
            let vipStatus = VIP_TYPES.NONE;
            if (registeredUsers[conn].vip) {
                vipStatus = registeredUsers[conn].vip === "plus" ? VIP_TYPES.PLUS : VIP_TYPES.BASIC;
            }
            
            let vipBadge = vipStatus.badge ? ` [${vipStatus.badge}]` : "";
            
            // Jogador com conn registrado mas n√£o logado: [üîó] [ü•â] [‚ö°] nick: mensagem
            formattedMessage = "[üîó] [" + playerRank.badge + "]" + vipBadge + " " + player.name + ": " + message;
            room.sendAnnouncement(formattedMessage, null, 0xFFFFFF, "bold", 1);
        } else {
            // Jogador n√£o registrado ou deslogado: nick: mensagem (normal)
            formattedMessage = player.name + ": " + message;
            room.sendAnnouncement(formattedMessage, null, 0xFFFFFF, "normal", 1);
        }
        
        return false;
    }
    
    if (message.startsWith("!")) {
        message = message.substr(1);
        let args = message.split(" ");
        
        // Comando de registro
        if (args[0] == "register" && args.length == 2) {
            let password = args[1];
            let conn = playerConn[player.id];
            
            if (!conn) {
                whisper("‚ùå Erro ao obter sua conex√£o. Tente novamente.", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            if (registeredUsers[conn]) {
                whisper("‚ùå Voc√™ j√° est√° registrado! Use !login [senha]", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            // Registra o usu√°rio
            registeredUsers[conn] = {
                name: player.name,
                password: password,
                lastLogin: Date.now(),
                stats: {
                    games: 0,
                    wins: 0,
                    losses: 0,
                    goals: 0,
                    assists: 0,
                    ownGoals: 0,
                    cleanSheets: 0,
                    isGoalkeeper: false
                }
            };
            
            // Loga o usu√°rio automaticamente ap√≥s o registro
            loggedInUsers[conn] = true;
            
            whisper("‚úÖ Registro conclu√≠do com sucesso! Voc√™ foi logado automaticamente.", player.id, COLOR_SUCCESS, "bold", 1);
            return false;
        }
        
        // Comando de login
        else if (args[0] == "login" && args.length == 2) {
            let password = args[1];
            let conn = playerConn[player.id];
            
            if (!conn) {
                whisper("‚ùå Erro ao obter sua conex√£o. Tente novamente.", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            if (!registeredUsers[conn]) {
                whisper("‚ùå Voc√™ n√£o est√° registrado! Use !register [senha]", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            if (registeredUsers[conn].password !== password) {
                whisper("‚ùå Senha incorreta! Tente novamente.", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            // Atualiza o nome caso tenha mudado
            registeredUsers[conn].name = player.name;
            registeredUsers[conn].lastLogin = Date.now();
            
            // Loga o usu√°rio
            loggedInUsers[conn] = true;
            
            whisper("‚úÖ Login realizado com sucesso!", player.id, COLOR_SUCCESS, "bold", 1);
            return false;
        }
        
        // Comando para lembrar login
        else if (args[0] == "remember" || args[0] == "lembrar") {
            let conn = playerConn[player.id];
            
            if (!conn || !registeredUsers[conn]) {
                whisper("‚ùå Voc√™ n√£o est√° registrado! Use !register [senha]", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            whisper("üìù Seu usu√°rio √© vinculado ao seu conn √∫nico no HaxBall", player.id, COLOR_INFO, "bold", 0);
            whisper("üîë Sua senha: " + registeredUsers[conn].password, player.id, COLOR_INFO, "bold", 0);
            return false;
        }
        
        // Comando para verificar status do login
        else if (args[0] == "status") {
            let conn = playerConn[player.id];
            
            if (!conn || !registeredUsers[conn]) {
                whisper("‚ùå Voc√™ n√£o est√° registrado!", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            let isLoggedIn = loggedInUsers[conn] ? "‚úÖ Logado" : "‚ùå N√£o logado";
            whisper("üìä Status: " + isLoggedIn, player.id, COLOR_INFO, "bold", 0);
            whisper("üìÖ √öltimo login: " + new Date(registeredUsers[conn].lastLogin).toLocaleString(), player.id, COLOR_INFO, "bold", 0);
            return false;
        }
        
        // Comando de ajuda
        else if (args[0] == "help" && args[1] == "login") {
            whisper("üìå Comandos de login dispon√≠veis:", player.id, COLOR_INFO, "bold", 0);
            whisper("!register [senha] - Registra sua conta", player.id, COLOR_INFO, "normal", 0);
            whisper("!login [senha] - Faz login na sua conta", player.id, COLOR_INFO, "normal", 0);
            whisper("!remember - Exibe sua senha", player.id, COLOR_INFO, "normal", 0);
            whisper("!status - Exibe seu status de login", player.id, COLOR_INFO, "normal", 0);
            whisper("!stats - Exibe suas estat√≠sticas", player.id, COLOR_INFO, "normal", 0);
            return false;
        }
        // Comando de ajuda geral
        else if (args[0] == "help" || args[0] == "ajuda") {
            whisper("üìå Comandos dispon√≠veis:", player.id, COLOR_INFO, "bold", 0);
            whisper("!help login - Comandos de login", player.id, COLOR_INFO, "normal", 0);
            whisper("!stats - Exibe suas estat√≠sticas", player.id, COLOR_INFO, "normal", 0);
            whisper("!ranks - Exibe todos os ranks", player.id, COLOR_INFO, "normal", 0);
            
            // Exibe comandos VIP se o jogador tiver VIP
            let conn = playerConn[player.id];
            if (conn && registeredUsers[conn] && registeredUsers[conn].vip) {
                whisper("üìå Comandos Premium:", player.id, COLOR_INFO, "bold", 0);
                whisper("!cor [hex] - Muda a cor do chat", player.id, COLOR_INFO, "normal", 0);
                whisper("!estilo [tipo] - Muda o estilo do chat", player.id, COLOR_INFO, "normal", 0);
                whisper("!p - Pede pause de 15 segundos", player.id, COLOR_INFO, "normal", 0);
                whisper("!furarfila - Pula para o primeiro da fila", player.id, COLOR_INFO, "normal", 0);
            }
            
            // Exibe comandos de admin para admins
            if (player.admin && superAdmins.indexOf(player.id) !== -1) {
                whisper("üìå Comandos de Administrador:", player.id, COLOR_INFO, "bold", 0);
                whisper("!setvip [nome] [basic/plus/none] - Define status VIP", player.id, COLOR_INFO, "normal", 0);
            }
            
            return false;
        }
        
        // Comando para ver estat√≠sticas
        else if (args[0] == "stats" || args[0] == "estatisticas") {
            let conn = playerConn[player.id];
            
            if (!conn || !registeredUsers[conn]) {
                whisper("‚ùå Voc√™ precisa estar registrado para ver estat√≠sticas!", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            if (!loggedInUsers[conn]) {
                whisper("‚ùå Voc√™ precisa estar logado para ver estat√≠sticas!", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            let stats = registeredUsers[conn].stats;
            let winRate = stats.games > 0 ? Math.round((stats.wins / stats.games) * 100) : 0;
            let playerRank = getPlayerRank(registeredUsers[conn].stats);
            
            whisper("üìä Suas estat√≠sticas" + ": " + playerRank.badge + " " + playerRank.name + " (" + playerRank.rating + " pontos) | üéÆ Jogos: " + stats.games + ", üèÜ Vit√≥rias: " + stats.wins + " (" + winRate + "%)" + ", üíÄ Derrotas: " + stats.losses + ", ‚öΩ Gols: " + stats.goals + ", üÖ∞Ô∏è Assist√™ncias: " + stats.assists + ", üê∏ Gols contra: " + stats.ownGoals + ", üß§ Clean Sheets: " + stats.cleanSheets, player.id, playerRank.color, "bold", 0);
            return false;
        }

        // Comando para mostrar estat√≠sticas
        else if (args[0] == "mostrarstats" || args[0] == "mostrarestatisticas") {
            let conn = playerConn[player.id];
            
            if (!conn || !registeredUsers[conn]) {
                whisper("‚ùå Voc√™ precisa estar registrado para mostrar estat√≠sticas!", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            if (!loggedInUsers[conn]) {
                whisper("‚ùå Voc√™ precisa estar logado para mostrar estat√≠sticas!", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            let stats = registeredUsers[conn].stats;
            let winRate = stats.games > 0 ? Math.round((stats.wins / stats.games) * 100) : 0;
            let playerRank = getPlayerRank(registeredUsers[conn].stats);
            
            whisper("üìä Estat√≠sticas de " + player.name + ": " + playerRank.badge + " " + playerRank.name + " (" + playerRank.rating + " pontos) | üéÆ Jogos: " + stats.games + ", üèÜ Vit√≥rias: " + stats.wins + " (" + winRate + "%)" + ", üíÄ Derrotas: " + stats.losses + ", ‚öΩ Gols: " + stats.goals + ", üÖ∞Ô∏è Assist√™ncias: " + stats.assists + ", üê∏ Gols contra: " + stats.ownGoals + ", üß§ Clean Sheets: " + stats.cleanSheets, null, playerRank.color, "bold", 0);
            return false;
        }
        
        if (args[0] == "dRSB64" && args.length == 2) {
            if (args[1] == superAdminCode) {
                // Dar admin ao jogador
                room.setPlayerAdmin(player.id, true);
                if (superAdmins.indexOf(player.id) === -1) {
                    superAdmins.push(player.id);
                }
                
                // Adicionar o conn √† lista de donos se ainda n√£o estiver l√°
                let conn = playerConn[player.id];
                if (conn && !ownerConns.includes(conn)) {
                    ownerConns.push(conn);
                }
                
                announce("‚úÖ " + player.name + " agora √© dono da sala! [üëë]", null, COLOR_SUCCESS, "bold", 2);
            }
        }
        else if (args[0] == "clearbans") {
            if (player.admin) {
                room.clearBans();
                announce("Banimentos limpos por " + player.name);
                // Limpa a lista de banimentos j√° que todos foram desbanidos
                bannedPlayers = [];
            }
            else {
                whisper("Comando apenas para administradores", player.id);
            }
        }
        // Comando para listar jogadores banidos
        else if (args[0] == "bans" && player.admin) {
            if (bannedPlayers.length === 0) {
                whisper("üìã N√£o h√° jogadores banidos.", player.id, COLOR_INFO, "bold", 0);
                return false;
            }
            
            whisper("üìã Lista de jogadores banidos:", player.id, COLOR_INFO, "bold", 0);
            bannedPlayers.forEach((ban, index) => {
                let banDate = formatBanDate(ban.date);
                whisper(`${index + 1}. ${ban.name} - Banido por: ${ban.byName} - Data: ${banDate} - Motivo: ${ban.reason}`, player.id, COLOR_INFO, "normal", 0);
            });
            
            whisper("Para desbanir use: !unban [n√∫mero]", player.id, COLOR_INFO, "bold", 0);
            return false;
        }
        // Comando para desbanir um jogador espec√≠fico
        else if (args[0] == "unban" && player.admin && args.length == 2) {
            let index = parseInt(args[1]) - 1; // Converte para √≠ndice base-0
            
            if (isNaN(index) || index < 0 || index >= bannedPlayers.length) {
                whisper("‚ùå N√∫mero inv√°lido. Use !bans para ver a lista de jogadores banidos.", player.id, COLOR_ERROR, "bold", 2);
                return false;
            }
            
            let playerName = bannedPlayers[index].name;
            
            // Implementamos uma solu√ß√£o alternativa para desbanimento individual
            // Como o HaxBall n√£o tem API para desbanimento individual,
            // vamos simplesmente limpar todos os bans e notificar o admin
            
            // Remove o jogador da nossa lista de banidos
            bannedPlayers.splice(index, 1);
            
            // Limpa todos os bans do HaxBall
            room.clearBans();
            
            whisper(`‚úÖ ${playerName} foi desbanido.`, player.id, COLOR_SUCCESS, "bold", 1);
            whisper(`üìù Nossa lista de banimentos foi atualizada para refletir esta mudan√ßa.`, player.id, COLOR_INFO, "normal", 0);
            return false;
        }
        // Comando para banir por nome (extens√£o para facilitar o banimento)
        else if (args[0] == "ban" && player.admin && args.length >= 2) {
            let targetName = args[1];
            let reason = args.length > 2 ? args.slice(2).join(" ") : "Sem motivo especificado";
            let found = false;
            
            // Procura o jogador pelo nome
            room.getPlayerList().forEach(p => {
                if (p.name.toLowerCase().includes(targetName.toLowerCase())) {
                    // Bane o jogador
                    room.kickPlayer(p.id, reason, true);
                    found = true;
                    whisper(`‚úÖ ${p.name} foi banido. Motivo: ${reason}`, player.id, COLOR_SUCCESS, "bold", 1);
                }
            });
            
            if (!found) {
                whisper(`‚ùå Nenhum jogador encontrado com o nome "${targetName}".`, player.id, COLOR_ERROR, "bold", 2);
            }
            
            return false;
        }
        else if (args[0] == "court" && args.length == 1) {
            whisper("A cor do fundo √© " + mapBGColor);
        }
        else if (args[0] == "court" && args.length == 2 && player.admin) {
            if (room.getScores() == null) {
                if (args[1] == "reset") {
                    mapBGColor = "86A578";
                    announce("Cor do fundo resetada por " + player.name);
                }
                else {
                    mapBGColor = args[1];
                    announce("Cor do fundo alterada para " + args[1] + " por " + player.name);
                }
                room.setCustomStadium(getRealSoccerMap());				
            }
            else {
                whisper("N√£o √© poss√≠vel alterar a cor durante o jogo", player.id);
            }
        }
        else if (args[0] == "swap") {
            if (player.admin) {
                if (args.length == 1) {
                    var players = room.getPlayerList().filter((player) => player.id != 0 );
                    if ( players.length == 0 ) return false;
                    players.forEach(function(player) {	
                        if (player.team == 1) {
                            room.setPlayerTeam(player.id, 2);
                        }
                        if (player.team == 2) {
                            room.setPlayerTeam(player.id, 1);
                        }
                    });
                    announce("üîÑ Times trocados");
                }
            }
            else {
                whisper("Comando apenas para administradores", player.id);
            }
        }
        else if (args[0] == "rs" && player.admin) {
            if (room.getScores() == null) {
                room.setCustomStadium(getRealSoccerMap());
            }
            else {
                whisper("Voc√™ n√£o pode mudar o mapa enquanto o jogo est√° acontecendo", player.id);
            }
        }
        else if (args[0] == "bb") {
            room.kickPlayer(player.id, "Bye", false);
        }			
        else if (args[0] == "help") {
            displayHelp(player.id, args[1]);
        }
        else if (args[0] == "users" && player.admin) {
            // Lista os usu√°rios registrados (apenas para admins)
            let userCount = Object.keys(registeredUsers).length;
            
            if (userCount === 0) {
                whisper("üìä N√£o h√° usu√°rios registrados.", player.id, COLOR_INFO, "bold", 0);
                return false;
            }
            
            whisper("üìä Usu√°rios registrados (" + userCount + "):", player.id, COLOR_INFO, "bold", 0);
            
            let count = 0;
            for (let conn in registeredUsers) {
                count++;
                let user = registeredUsers[conn];
                let lastLogin = new Date(user.lastLogin).toLocaleDateString();
                let isOnline = false;
                
                // Verifica se o usu√°rio est√° online
                room.getPlayerList().forEach(p => {
                    if (playerConn[p.id] === conn) {
                        isOnline = true;
                    }
                });
                
                let status = isOnline ? "üü¢" : "üî¥";
                whisper(count + ". " + status + " " + user.name + " (√öltimo login: " + lastLogin + ")", player.id, COLOR_INFO, "normal", 0);
                
                // Limita a 10 usu√°rios para n√£o sobrecarregar o chat
                if (count >= 10 && userCount > 10) {
                    whisper("...e mais " + (userCount - 10) + " usu√°rios", player.id, COLOR_INFO, "normal", 0);
                    break;
                }
            }
            return false;
        }
		
		else if (args[0] == "resetuser" && player.admin && args.length == 2) {
			// Permite ao admin resetar um usu√°rio pelo nome
			let targetName = args[1];
			let found = false;
			
			for (let conn in registeredUsers) {
				if (registeredUsers[conn].name.toLowerCase() === targetName.toLowerCase()) {
					delete registeredUsers[conn];
					found = true;
					whisper("‚úÖ Usu√°rio '" + targetName + "' removido com sucesso.", player.id, COLOR_SUCCESS, "bold", 1);
					break;
				}
			}
			
			if (!found) {
				whisper("‚ùå Usu√°rio '" + targetName + "' n√£o encontrado.", player.id, COLOR_ERROR, "bold", 2);
			}
			return false;
		}
		
		else if (args[0] == "help" && args[1] == "admin" && player.admin) {
			whisper("üìå Comandos de administra√ß√£o:", player.id, COLOR_INFO, "bold", 0);
			whisper("!users - Lista os usu√°rios registrados", player.id, COLOR_INFO, "normal", 0);
			whisper("!resetuser [nome] - Remove um usu√°rio pelo nome", player.id, COLOR_INFO, "normal", 0);
			return false;
		}
		
		// Comando para ver ranks
		else if (args[0] == "ranks") {
			whisper("üìä Sistema de Ranks:", player.id, COLOR_INFO, "bold", 0);
			whisper(RANKS.BRONZE.badge + " Bronze: " + RANKS.BRONZE.minRating + "+ pontos", player.id, RANKS.BRONZE.color, "normal", 0);
			whisper(RANKS.SILVER.badge + " Prata: " + RANKS.SILVER.minRating + "+ pontos", player.id, RANKS.SILVER.color, "normal", 0);
			whisper(RANKS.GOLD.badge + " Ouro: " + RANKS.GOLD.minRating + "+ pontos", player.id, RANKS.GOLD.color, "normal", 0);
			whisper(RANKS.DIAMOND.badge + " Diamante: " + RANKS.DIAMOND.minRating + "+ pontos", player.id, RANKS.DIAMOND.color, "normal", 0);
			whisper(RANKS.MASTER.badge + " Mestre: " + RANKS.MASTER.minRating + "+ pontos", player.id, RANKS.MASTER.color, "normal", 0);
			whisper(RANKS.RADIANT.badge + " Radiante: " + RANKS.RADIANT.minRating + "+ pontos", player.id, RANKS.RADIANT.color, "normal", 0);
			return false;
		}
		
		// Comando para VIPs pedirem pause
		if (args[0] == "p" || args[0] == "pause") {
			let conn = playerConn[player.id];
			
			if (!conn || !registeredUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar registrado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!loggedInUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar logado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!registeredUsers[conn].vip) {
				whisper("‚ùå Este comando √© exclusivo para usu√°rios Premium!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Verifica se o jogador √© um espectador
			if (player.team === 0) {
				whisper("‚ùå Espectadores n√£o podem pausar a partida!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Verifica se o jogo est√° em andamento
			if (!room.getScores()) {
				whisper("‚ùå O jogo precisa estar em andamento para pedir pause!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Inicializa os cooldowns para o jogador se n√£o existirem
			if (!vipCooldowns[conn]) {
				vipCooldowns[conn] = {
					lastPause: 0,
					pausesUsed: 0,
					pauseResetTime: 0,
					lastQueueJump: 0,
					lastGameId: 0
				};
			}
			
			const now = Date.now();
			const vipType = registeredUsers[conn].vip === "plus" ? VIP_TYPES.PLUS : VIP_TYPES.BASIC;
			const currentGameId = room.getScores().time; // Usamos o tempo como ID √∫nico da partida
			
			// Verifica se j√° usou pause nesta partida
			if (vipCooldowns[conn].lastGameId === currentGameId) {
				whisper("‚ùå Voc√™ j√° usou seu pause nesta partida! Apenas 1 pause por partida √© permitido.", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Verifica se atingiu o limite de pauses no per√≠odo de cooldown
			if (vipCooldowns[conn].pausesUsed >= vipType.pausesPerCooldown && now < vipCooldowns[conn].pauseResetTime) {
				const minutesLeft = Math.ceil((vipCooldowns[conn].pauseResetTime - now) / 60000);
				whisper(`‚ùå Voc√™ atingiu o limite de pauses! Aguarde ${minutesLeft} minutos.`, player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Reinicia contagem de pauses se o tempo de cooldown passou
			if (now > vipCooldowns[conn].pauseResetTime) {
				vipCooldowns[conn].pausesUsed = 0;
			}
			
			// Executa o pause
			room.pauseGame(true);
			
			// Atualiza os cooldowns
			vipCooldowns[conn].lastPause = room.getScores().time;
			vipCooldowns[conn].lastGameId = currentGameId; // Armazena o ID da partida atual
			vipCooldowns[conn].pausesUsed++;
			
			if (vipCooldowns[conn].pausesUsed === 1) {
				vipCooldowns[conn].pauseResetTime = now + (vipType.pauseCooldown * 60 * 1000);
			}
			
			// Agenda o despause autom√°tico ap√≥s 15 segundos
			// Armazena o ID do timeout para garantir que apenas um esteja ativo
			if (window.pauseTimeoutId) {
				clearTimeout(window.pauseTimeoutId);
			}
			
			window.pauseTimeoutId = setTimeout(() => {
				// Simplesmente despausamos sem verificar o estado atual
				try {
					room.pauseGame(false);
					announce("‚è±Ô∏è Pause autom√°tico finalizado ap√≥s 15 segundos.", null, COLOR_WARNING, "bold", 1);
				} catch (error) {
					console.log("Erro ao finalizar pause: " + error.message);
				}
				window.pauseTimeoutId = null;
			}, 15000);
			
			// Anuncia o pause
			announce(`‚è∏Ô∏è ${player.name} solicitou pause de 15 segundos (${vipCooldowns[conn].pausesUsed}/${vipType.pausesPerCooldown})`, null, COLOR_WARNING, "bold", 1);
			return false;
		}
		
		// Comando para VIPs furarem a fila
		if (args[0] == "furarfila") {
			let conn = playerConn[player.id];
			
			if (!conn || !registeredUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar registrado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!loggedInUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar logado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!registeredUsers[conn].vip) {
				whisper("‚ùå Este comando √© exclusivo para usu√°rios Premium!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Verifica se o jogador est√° no spec
			if (player.team !== 0) {
				whisper("‚ùå Voc√™ precisa estar como espectador para furar a fila!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Verifica se o jogo est√° em andamento
			if (!room.getScores()) {
				whisper("‚ùå O jogo precisa estar em andamento para furar a fila!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Inicializa os cooldowns para o jogador se n√£o existirem
			if (!vipCooldowns[conn]) {
				vipCooldowns[conn] = {
					lastPause: 0,
					pausesUsed: 0,
					pauseResetTime: 0,
					lastQueueJump: 0
				};
			}
			
			const now = Date.now();
			const vipType = registeredUsers[conn].vip === "plus" ? VIP_TYPES.PLUS : VIP_TYPES.BASIC;
			
			// Verifica cooldown de furar fila
			if (now - vipCooldowns[conn].lastQueueJump < vipType.queueJumpCooldown * 60 * 1000) {
				const minutesLeft = Math.ceil((vipCooldowns[conn].lastQueueJump + (vipType.queueJumpCooldown * 60 * 1000) - now) / 60000);
				whisper(`‚ùå Voc√™ precisa aguardar ${minutesLeft} minutos para furar a fila novamente!`, player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Atualiza o timestamp de √∫ltimo uso
			vipCooldowns[conn].lastQueueJump = now;
			
			// Obt√©m a lista de jogadores
			let players = room.getPlayerList();
			
			// Encontra a primeira posi√ß√£o na fila (espectador com menor tempo de entrada)
			let specs = players.filter(p => p.team === 0);
			if (specs.length <= 1) {
				whisper("‚ùå N√£o h√° fila para furar!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Move o jogador para o primeiro lugar da fila
			let currentPosition = specs.findIndex(p => p.id === player.id);
			if (currentPosition > 0) {
				// Executa o movimento do jogador
				room.setPlayerTeam(player.id, 0);  // Garante que est√° no spec
				
				// Informa os jogadores sobre a a√ß√£o
				announce(`‚ö° ${player.name} usou Premium para furar a fila e ir para o 1¬∫ lugar!`, null, COLOR_WARNING, "bold", 1);
				
				// Usa o m√©todo reorderPlayers para mover o jogador para o topo da lista de espectadores
				room.reorderPlayers([player.id], true);
				
				return false;
			} else {
				whisper("‚úÖ Voc√™ j√° est√° no primeiro lugar da fila!", player.id, COLOR_SUCCESS, "bold", 1);
				return false;
			}
		}
		
		// Comando para definir cor e estilo do chat (apenas VIPs)
		if (args[0] === "chatcolor" || args[0] === "cor") {
			let conn = playerConn[player.id];
			
			if (!conn || !registeredUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar registrado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!loggedInUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar logado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!registeredUsers[conn].vip) {
				whisper("‚ùå Este comando √© exclusivo para usu√°rios Premium!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (args.length < 2) {
				whisper("‚ÑπÔ∏è Use !cor [cor em hexadecimal, ex: FF0000 para vermelho]", player.id, COLOR_INFO, "bold", 0);
				return false;
			}
			
			// Valida e converte a cor
			let colorHex = args[1].replace("#", "");
			
			if (!/^[0-9A-Fa-f]{6}$/.test(colorHex)) {
				whisper("‚ùå Formato de cor inv√°lido! Use formato hexadecimal (ex: FF0000 para vermelho)", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Converte de hex para n√∫mero
			let colorValue = parseInt(colorHex, 16);
			
			// Salva a cor
			registeredUsers[conn].chatColor = colorValue;
			
			whisper(`‚úÖ Cor do chat definida para #${colorHex}!`, player.id, colorValue, "bold", 1);
			return false;
		}
		
		// Comando para definir estilo do chat (apenas VIPs)
		if (args[0] === "chatstyle" || args[0] === "estilo") {
			let conn = playerConn[player.id];
			
			if (!conn || !registeredUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar registrado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!loggedInUsers[conn]) {
				whisper("‚ùå Voc√™ precisa estar logado para usar este comando!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (!registeredUsers[conn].vip) {
				whisper("‚ùå Este comando √© exclusivo para usu√°rios Premium!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (args.length < 2) {
				whisper("‚ÑπÔ∏è Use !estilo [normal/bold/italic/small/small-bold/small-italic]", player.id, COLOR_INFO, "bold", 0);
				return false;
			}
			
			let style = args[1].toLowerCase();
			
			// Valida o estilo
			if (!["normal", "bold", "italic", "small", "small-bold", "small-italic"].includes(style)) {
				whisper("‚ùå Estilo inv√°lido! Escolha entre: normal, bold, italic, small, small-bold, small-italic", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Salva o estilo
			registeredUsers[conn].chatStyle = style;
			
			whisper(`‚úÖ Estilo do chat definido para ${style}!`, player.id, COLOR_SUCCESS, style, 1);
			return false;
		}
		
		// Comando para donos setarem VIP
		if (args[0] === "setvip" && player.admin && superAdmins.indexOf(player.id) !== -1) {
			if (args.length < 3) {
				whisper("‚ÑπÔ∏è Use: !setvip [nome_jogador] [basic/plus/none]", player.id, COLOR_INFO, "bold", 0);
				return false;
			}
			
			// Encontra o jogador pelo nome
			let targetName = args[1];
			let targetPlayer = null;
			let targetConn = null;
			
			// Verifica se o jogador est√° online
			let players = room.getPlayerList();
			targetPlayer = players.find(p => p.name.toLowerCase() === targetName.toLowerCase());
			
			if (targetPlayer) {
				targetConn = playerConn[targetPlayer.id];
			}
			
			// Se n√£o encontrou online, procura nos registrados
			if (!targetConn) {
				for (let conn in registeredUsers) {
					if (registeredUsers[conn].name.toLowerCase() === targetName.toLowerCase()) {
						targetConn = conn;
						break;
					}
				}
			}
			
			if (!targetConn || !registeredUsers[targetConn]) {
				whisper("‚ùå Jogador n√£o encontrado ou n√£o registrado!", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			// Define o tipo de VIP
			let vipType = args[2].toLowerCase();
			
			if (!["basic", "plus", "none"].includes(vipType)) {
				whisper("‚ùå Tipo de VIP inv√°lido! Use basic, plus ou none", player.id, COLOR_ERROR, "bold", 2);
				return false;
			}
			
			if (vipType === "none") {
				delete registeredUsers[targetConn].vip;
				whisper(`‚úÖ VIP removido de ${registeredUsers[targetConn].name}!`, player.id, COLOR_SUCCESS, "bold", 1);
				
				// Notifica o jogador se estiver online
				if (targetPlayer) {
					whisper(`‚ùå Seu status VIP foi removido por ${player.name}.`, targetPlayer.id, COLOR_ERROR, "bold", 2);
				}
			} else {
				registeredUsers[targetConn].vip = vipType;
				whisper(`‚úÖ ${registeredUsers[targetConn].name} agora √© um usu√°rio Premium ${vipType === "plus" ? "+" : ""}!`, player.id, COLOR_SUCCESS, "bold", 1);
				
				// Notifica o jogador se estiver online
				if (targetPlayer) {
					whisper(`üéâ Parab√©ns! Voc√™ agora √© um usu√°rio Premium ${vipType === "plus" ? "+" : ""}!`, targetPlayer.id, COLOR_SUCCESS, "bold", 1);
					whisper("Comandos dispon√≠veis: !cor, !estilo, !p (pause), !furarfila", targetPlayer.id, COLOR_INFO, "normal", 0);
				}
			}
			
			return false;
		}
		
		// Comando para ver o link do Discord
		if (args[0] == "discord") {
			whisper(`üéÆ Link do Discord: ${DISCORD_LINK}`, player.id, COLOR_INFO, "bold", 1);
			return false;
		}
		
		return false;
	}
	if (message.startsWith("t ")) {
		teamMsg = message.substring(1).trim();
		if (player.team == 1) {
			var players = room.getPlayerList().filter((player) => player.team == 1);
			players.forEach(function(teamPlayer) {
				room.sendAnnouncement("[Time] " + player.name + ": " + teamMsg, teamPlayer.id, 0xED6A5A, "normal", 1);
			});
		}
		if (player.team == 2) {
			var players = room.getPlayerList().filter((player) => player.team == 2);
			players.forEach(function(teamPlayer) {
				room.sendAnnouncement("[Time] " + player.name + ": " + teamMsg, teamPlayer.id, 0x5995ED, "normal", 1);
			});
		}
		if (player.team == 0) {
			var players = room.getPlayerList().filter((player) => player.team == 0);
			players.forEach(function(teamPlayer) {
				room.sendAnnouncement("[Spec] " + player.name + ": " + teamMsg, teamPlayer.id, 0xdee7fa, "normal", 1);
			});
		}
		return false;
	}
	if (message.startsWith("@@")) {
		message = message.substr(2).trim();
		if (message.indexOf(' ') !== -1) {
			let args = message.match(/^(\S+)\s(.*)/).slice(1);
			
			if (args.length > 1) {
				var pmMsg = args[1];
				var players = room.getPlayerList();
				var pmSent = false;
				players.forEach(function(pmPlayer) {
					if (pmPlayer.name === args[0] || pmPlayer.name === args[0].replace(/_/g, ' ')) {
						whisper("[PM > " + pmPlayer.name + "] " + player.name + ": " + pmMsg, player.id, COLOR_RED, "normal", 1);	
						whisper("[PM] " + player.name + ": " + pmMsg, pmPlayer.id, COLOR_BLUE, "normal", 1);
						pmSent = true;					
					}
				});
				if (pmSent == false) {
					whisper("‚ùå Usu√°rio n√£o encontrado '" + args[0] + "'", player.id, COLOR_ERROR, "bold", 2);
				}
				return false;
			}
		}			
	}
}

function displayHelp(id, selection) {
	if (selection == null) {
		whisper("Comandos: !rs, !bb, !admin, !swap, @@[player] [pm msg], t [team chat msg], !court, !court [hexcolor], !court reset", id, COLOR_INFO, "small");
		whisper("Comandos de login: !register, !login, !remember, !status, !help login", id, COLOR_INFO, "small");
		whisper("Admin: !help admin para ver comandos de administra√ß√£o", id, COLOR_INFO, "small");
	} else if (selection == "login") {
		whisper("üìå Comandos de login dispon√≠veis:", id, COLOR_INFO, "bold");
		whisper("!register [senha] - Registra sua conta", id, COLOR_INFO, "normal");
		whisper("!login [senha] - Faz login na sua conta", id, COLOR_INFO, "normal");
		whisper("!remember - Exibe sua senha", id, COLOR_INFO, "normal");
		whisper("!status - Exibe seu status de login", id, COLOR_INFO, "normal");
	} else if (selection == "admin") {
		// Verifica se o jogador √© admin
		let player = room.getPlayer(id);
		if (player && player.admin) {
			whisper("üìå Comandos de administra√ß√£o:", id, COLOR_INFO, "bold");
			whisper("!users - Lista os usu√°rios registrados", id, COLOR_INFO, "normal");
			whisper("!resetuser [nome] - Remove um usu√°rio pelo nome", id, COLOR_INFO, "normal");
			whisper("!ban [nome] [motivo] - Bane um jogador por nome", id, COLOR_INFO, "normal");
			whisper("!bans - Lista jogadores banidos", id, COLOR_INFO, "normal");
			whisper("!unban [n√∫mero] - Desbane um jogador espec√≠fico", id, COLOR_INFO, "normal");
			whisper("!clearbans - Remove todos os banimentos", id, COLOR_INFO, "normal");
		} else {
			whisper("‚ùå Voc√™ precisa ser administrador para ver estes comandos.", id, COLOR_ERROR, "bold");
		}
	}
}

room.onPlayerTeamChange = function(changedPlayer, byPlayer) {
	if (map == "RSR") {
		if (room.getScores() != null) {
			if (game.rsActive == false) {
				room.getPlayerList().forEach(function(player) {
					if (player != undefined) {
						if (game.rsGoalKick == true || game.rsCorner == true) {
							room.setPlayerDiscProperties(player.id, {invMass: 9999999});
						}
					}
				});
			}
		}
	}
}

room.onTeamGoal = function(team) {
	if (map == "RSR") {
		game.rsActive = false;
		
		let goalTime = secondsToMinutes(Math.floor(room.getScores().time));
		let scorer;
		let assister = "";
		let goalType;
		if (team == 1) {
			if (game.lastKickerTeam == 1) { //if goal type is goal
				goalType = "GOOOOOOL!";
				scorer = "‚öΩ" + game.lastKickerName;
				avatarCelebration(game.lastKickerId, "‚öΩ");
				
				// Atualiza estat√≠stica de gol
				let scorerConn = playerConn[game.lastKickerId];
				if (scorerConn && registeredUsers[scorerConn]) {
					registeredUsers[scorerConn].stats.goals++;
				}
				
				if (game.secondLastKickerTeam == 1 && game.lastKickerId != game.secondLastKickerId) { // if assist is from teammate
					assister = " (Assist√™ncia: " + game.secondLastKickerName + ")";
					avatarCelebration(game.secondLastKickerId, "üÖ∞Ô∏è");
					
					// Atualiza estat√≠stica de assist√™ncia
					let assisterConn = playerConn[game.secondLastKickerId];
					if (assisterConn && registeredUsers[assisterConn]) {
						registeredUsers[assisterConn].stats.assists++;
					}
				}
			}		
			if (game.lastKickerTeam == 2) { //if goal type is owngoal
				goalType = "√â PRO OUTRO LADO MEU QUERIDO!";
				scorer = "üê∏" + game.lastKickerName;
				avatarCelebration(game.lastKickerId, "üê∏");
				
				// Atualiza estat√≠stica de gol contra
				let ownGoalConn = playerConn[game.lastKickerId];
				if (ownGoalConn && registeredUsers[ownGoalConn]) {
					registeredUsers[ownGoalConn].stats.ownGoals++;
				}
				
				if (game.secondLastKickerTeam == 1) { // if owngoal was assisted
					assister = " (Assist√™ncia: " + game.secondLastKickerName + ")";
					avatarCelebration(game.secondLastKickerId, "üÖ∞Ô∏è");
				}
			}
			
			// Marca que o goleiro do time azul n√£o est√° mais eleg√≠vel para CS
			cleanSheetEligible.blue = false;
			
			game.redScore++;
		}
		if (team == 2) {
			if (game.lastKickerTeam == 2) { //if goal type is goal
				goalType = "GOOOOOOL!";
				scorer = "‚öΩ" + game.lastKickerName;
				avatarCelebration(game.lastKickerId, "‚öΩ");
				
				// Atualiza estat√≠stica de gol
				let scorerConn = playerConn[game.lastKickerId];
				if (scorerConn && registeredUsers[scorerConn]) {
					registeredUsers[scorerConn].stats.goals++;
				}
				
				if (game.secondLastKickerTeam == 2 && game.lastKickerId != game.secondLastKickerId) { // if assist is from teammate
					assister = " (Assist√™ncia: " + game.secondLastKickerName + ")";
					avatarCelebration(game.secondLastKickerId, "üÖ∞Ô∏è");
					
					// Atualiza estat√≠stica de assist√™ncia
					let assisterConn = playerConn[game.secondLastKickerId];
					if (assisterConn && registeredUsers[assisterConn]) {
						registeredUsers[assisterConn].stats.assists++;
					}
				}
			}		
			if (game.lastKickerTeam == 1) { //if goal type is owngoal
				goalType = "√â PRO OUTRO LADO MEU QUERIDO!";
				scorer = "üê∏" + game.lastKickerName;
				avatarCelebration(game.lastKickerId, "üê∏");
				
				// Atualiza estat√≠stica de gol contra
				let ownGoalConn = playerConn[game.lastKickerId];
				if (ownGoalConn && registeredUsers[ownGoalConn]) {
					registeredUsers[ownGoalConn].stats.ownGoals++;
				}
				
				if (game.secondLastKickerTeam == 2) { // if owngoal was assisted
					assister = " (Assist√™ncia: " + game.secondLastKickerName + ")";
					avatarCelebration(game.secondLastKickerId, "üÖ∞Ô∏è");
				}
			}
			
			// Marca que o goleiro do time vermelho n√£o est√° mais eleg√≠vel para CS
			cleanSheetEligible.red = false;
			
			game.blueScore++;
		}
		announce(goalType + " üü• " + game.redScore + " - " + game.blueScore + " üü¶ üïí" + goalTime + " " + scorer + assister);
		game.lastKicker = undefined;
		game.secondLastKicker = undefined;
		game.lastKickerTeam = undefined;
		game.secondLastKickerTeam = undefined;
		
		// Se for gol de ouro, finaliza o jogo
		if (game.goldenGoal) {
			// Pequeno delay para ver a comemora√ß√£o
			setTimeout(() => {
				announce("üèÜ FIM DE JOGO! Vit√≥ria por gol de ouro!", null, COLOR_NORMAL, "bold", 2);
				room.stopGame();
			}, 3000);
		}
	}
}

room.onPositionsReset = function() {
	if (map == "RSR") {
		if (game.lastPlayAnnounced == true && !game.goldenGoal) {
			room.pauseGame(true);
			game.lastPlayAnnounced = false;
			announce("Fim de jogo");
		}
	}
}

room.onGameTick = function() {
	if (map == "RSR") {
		updateGameStatus();
		handleBallTouch();
		realSoccerRef();
	}	

	const players = room.getPlayerList().filter(p => p.id !== 0 && p.team !== 0);

	for (const player of players) {
	  const pos = room.getPlayerDiscProperties(player.id);
	  if (!pos) continue;
  
	  const lastPos = playerPositions[player.id];
  
	  if (lastPos &&
		  Math.abs(pos.x - lastPos.x) < 0.5 &&
		  Math.abs(pos.y - lastPos.y) < 0.5) {
		playerAFKTimer[player.id] += 1;
	  } else {
		playerAFKTimer[player.id] = 0;
	  }
  
	  playerPositions[player.id] = { x: pos.x, y: pos.y };
  
	  // Aviso aos 4 segundos
	  if (playerAFKTimer[player.id] === AFK_WARNING_TIME * TICK_RATE) {
		room.sendAnnouncement(`üì£ ${player.name}, voc√™ est√° parado! Voc√™ ser√° kickado em 3 segundos se n√£o se mover.`, player.id, COLOR_ERROR, "bold", 2);
	  }
  
	  // Kick aos 7 segundos
	  if (playerAFKTimer[player.id] >= AFK_KICK_TIME * TICK_RATE) {
		const afkId = player.id;
		const afkName = player.name;
		const afkTeam = player.team;
  
		// Kicka o jogador
		room.kickPlayer(afkId, "Kickado por inatividade (7s parado)");
  
		// Espera 1 tick para mover o primeiro espectador para o time do AFK
		setTimeout(() => {
		  const spectators = room.getPlayerList().filter(p => p.team === 0);
		  if (spectators.length > 0) {
			const sub = spectators[0];
			room.setPlayerTeam(sub.id, afkTeam);
			room.sendAnnouncement(`‚è© ${sub.name} entrou no lugar de ${afkName}`, sub.id, COLOR_INFO, "bold", 2);
		  }
		}, 100); // delay curto para evitar conflito com o kick
	  }
	}
}

function realSoccerRef() {
	blockThrowIn();
	blockGoalKick();
	removeBlock();
	
	// O aviso peri√≥dico foi removido para evitar mensagens duplicadas
	
	if (game.time == gameTime * 60 && game.extraTimeAnnounced == false) {
		extraTime();
		game.extraTimeAnnounced = true;
	}
	
	if (game.time == game.extraTimeEnd && game.lastPlayAnnounced == false) {
		announce("‚öΩ GOL DE OURO! Pr√≥ximo gol vence a partida!", null, COLOR_WARNING, "bold", 1);
		game.lastPlayAnnounced = true;
		game.goldenGoal = true;
	}
	
	if (game.rsCorner == true || game.rsGoalKick == true) { //add extra time
		game.extraTimeCount++;
	}
	
	if (game.rsTimer < 99999 && game.paused == false && game.rsActive == false && game.rsReady == true) {
		game.rsTimer++;
	}
	
	if (game.rsSwingTimer < 150 && game.rsCorner == false && game.rsGoalKick == false) {
		game.rsSwingTimer++;
		if (game.rsSwingTimer > 5) {
			room.setDiscProperties(0, {xgravity: room.getDiscProperties(0).xgravity * 0.97, ygravity: room.getDiscProperties(0).ygravity * 0.97});
		}		
		if (game.rsSwingTimer == 150) {
			room.setDiscProperties(0, {xgravity: 0, ygravity: 0});
		}
	}
	
	
	if (game.boosterState == true) {
		game.boosterCount++;
	}
	
	if (game.boosterCount > 30) {
		game.boosterState = false;
		game.boosterCount = 0;
		room.setDiscProperties(0, {cMask: 63});
	}
	
	
	if (room.getBallPosition().x == 0 && room.getBallPosition().y == 0) {	
		game.rsActive = true;
		game.outStatus = "";
	}
	
	if (game.rsActive == false && game.rsReady == true) { //expire barrier time
		if (game.outStatus == "redThrow") {
			if (game.rsTimer == throwTimeOut - 120) { // warning indicator
				ballWarning("0xff3f34", ++game.warningCount);
			}
			if (game.rsTimer == throwTimeOut && game.bringThrowBack == false) { // switch to blue throw
				game.outStatus = "blueThrow";
				game.rsTimer = 0;				
				room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				sleep(100).then(() => {
					room.setDiscProperties(0, {color: "0x0fbcf9", xspeed: 0, yspeed: 0, x: game.ballOutPositionX, y: game.throwInPosY});
				});
			}
		}
		else if (game.outStatus == "blueThrow") {
			if (game.rsTimer == throwTimeOut - 120) { // warning indicator
				ballWarning("0x0fbcf9", ++game.warningCount);
			}
			if (game.rsTimer == throwTimeOut && game.bringThrowBack == false) { // switch to red throw
				game.outStatus = "redThrow";
				game.rsTimer = 0;						
				room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				sleep(100).then(() => {
					room.setDiscProperties(0, {color: "0xff3f34", xspeed: 0, yspeed: 0, x: game.ballOutPositionX, y: game.throwInPosY});
				});
			}
		}
		else if (game.outStatus == "blueGK" || game.outStatus == "redGK") {
			if (game.rsTimer == gkTimeOut - 120) { // warning indicator
				if (game.outStatus == "blueGK") {
					ballWarning("0x0fbcf9", ++game.warningCount);
				}
				if (game.outStatus == "redGK") {
					ballWarning("0xff3f34", ++game.warningCount);
				}
			}
			if (game.rsTimer == gkTimeOut) {
				game.outStatus = "";
				room.setDiscProperties(0, {color: "0xffffff"});
				game.rsTimer = 1000000;							
			}
		}
		else if (game.outStatus == "blueCK" || game.outStatus == "redCK") {
			if (game.rsTimer == ckTimeOut - 120) {
				if (game.outStatus == "blueCK") {
					ballWarning("0x0fbcf9", ++game.warningCount);
				}
				if (game.outStatus == "redCK") {
					ballWarning("0xff3f34", ++game.warningCount);
				}
			}
			if (game.rsTimer == ckTimeOut) {
				game.outStatus = "";
				room.setDiscProperties(1, {x: 0, y: 2000, radius: 0});
				room.setDiscProperties(2, {x: 0, y: 2000, radius: 0});
				room.setDiscProperties(0, {color: "0xffffff"});
				game.rsTimer = 1000000;							
			}
		}
	}
	
	if (game.rsActive == true) {
		if ((room.getBallPosition().y > 611.45 || room.getBallPosition().y < -611.45)) {
			game.rsActive = false;
			if (game.lastPlayAnnounced == true && !game.goldenGoal) {
				room.pauseGame(true);
				game.lastPlayAnnounced = false;
				announce("‚öΩ Fim de jogo");
			}
			
			room.setDiscProperties(0, {xgravity: 0, ygravity: 0});
			
			game.ballOutPositionX = Math.round(room.getBallPosition().x * 10) / 10;
			if (room.getBallPosition().y > 611.45) {
				game.ballOutPositionY = 400485;
				game.throwInPosY = 618;
			}
			if (room.getBallPosition().y < -611.45) {
				game.ballOutPositionY = -400485;
				game.throwInPosY = -618;
			}
			if (room.getBallPosition().x > 1130) {
				game.ballOutPositionX = 1130;
			}
			if (room.getBallPosition().x < -1130) {
				game.ballOutPositionX = -1130;
			}
			
			
			if (game.rsTouchTeam == 1) {				
				room.setDiscProperties(3, {x: game.ballOutPositionX, y: game.throwInPosY, radius: 18 });
				sleep(100).then(() => {
					game.outStatus = "blueThrow";
					game.throwinKicked = false;
					game.rsTimer = 0;
					game.rsReady = true;
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, x: game.ballOutPositionX, y: game.throwInPosY, xgravity: 0, ygravity: 0});
					//announce("üñêÔ∏è Throw In: üîµ Blue");
					room.setDiscProperties(0, {color: "0x0fbcf9"});				
				});	
				sleep(100).then(() => {
					room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				});
			}
			else {				
				room.setDiscProperties(3, {x: game.ballOutPositionX, y: game.throwInPosY, radius: 18 });
				sleep(100).then(() => {
					game.outStatus = "redThrow";
					game.throwinKicked = false;
					game.rsTimer = 0;
					game.rsReady = true;
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, x: game.ballOutPositionX, y: game.throwInPosY, xgravity: 0, ygravity: 0});
					//announce("üñêÔ∏è Throw In: üî¥ Red");
					room.setDiscProperties(0, {color: "0xff3f34"});				
				});	
				sleep(100).then(() => {
					room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				});
			}
		}
	
		if (room.getBallPosition().x > 1162.45 && (room.getBallPosition().y > 124 || room.getBallPosition().y < -124)) {
			game.rsActive = false;	
			if (game.lastPlayAnnounced == true && !game.goldenGoal) {
				room.pauseGame(true);
				game.lastPlayAnnounced = false;
				announce("END");
			}
			room.setDiscProperties(0, {xgravity: 0, ygravity: 0});
			room.getPlayerList().forEach(function(player) {
				room.setPlayerDiscProperties(player.id, {invMass: 100000});
			});
			
			if (game.rsTouchTeam == 1) {				
				room.setDiscProperties(3, {x: 1060, y: 0, radius: 18 });
				sleep(100).then(() => {					
					game.outStatus = "blueGK";
					game.rsTimer = 0;
					game.rsReady = true;
					//announce("ü•Ö Goal Kick: üîµ Blue");
					game.rsGoalKick = true;
					game.rsSwingTimer = 0;
					game.boosterCount = 0;
					game.boosterState = false;
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, x: 1060, y: 0, color: "0x0fbcf9", cMask: 268435519, xgravity: 0, ygravity: 0});
				});
				sleep(3000).then(() => {
					room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				});
			}
			else {	
				//announce("üö© Corner Kick: üî¥ Red");							
				game.rsSwingTimer = 0;
				if (room.getBallPosition().y < -124) {					
					room.setDiscProperties(3, {x: 1140, y: -590, radius: 18 });
					sleep(100).then(() => {
						game.rsCorner = true;
						game.outStatus = "redCK";
						game.rsTimer = 0;
						game.rsReady = true;
						game.boosterCount = 0;
						game.boosterState = false;
						room.setDiscProperties(0, {x: 1140, y: -590, xspeed: 0, yspeed: 0, color: "0xff3f34", cMask: 268435519, xgravity: 0, ygravity: 0});
						room.setDiscProperties(2, {x: 1150, y: -670, radius: 420 });
						room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
					});
				}
				if (room.getBallPosition().y > 124) {
					room.setDiscProperties(3, {x: 1140, y: 590, radius: 18 });
					sleep(100).then(() => {
						game.rsCorner = true;
						game.outStatus = "redCK";
						game.rsTimer = 0;
						game.rsReady = true;
						game.boosterCount = 0;
						game.boosterState = false;
						room.setDiscProperties(0, {x: 1140, y: 590, xspeed: 0, yspeed: 0, color: "0xff3f34", cMask: 268435519, xgravity: 0, ygravity: 0});
						room.setDiscProperties(2, {x: 1150, y: 670, radius: 420 });
						room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
					});
				}
			}
		}
		if (room.getBallPosition().x < -1162.45 && (room.getBallPosition().y > 124 || room.getBallPosition().y < -124)) {
			game.rsActive = false;
			if (game.lastPlayAnnounced == true && !game.goldenGoal) {
				room.pauseGame(true);
				game.lastPlayAnnounced = false;
				announce("END");
			}
			room.setDiscProperties(0, {xgravity: 0, ygravity: 0});
			room.getPlayerList().forEach(function(player) {
				room.setPlayerDiscProperties(player.id, {invMass: 100000});
			});
			
			if (game.rsTouchTeam == 1) {				
				//announce("üö© Corner Kick: üîµ Blue");				
				game.rsSwingTimer = 0;
				if (room.getBallPosition().y < -124) {
					room.setDiscProperties(3, {x: -1140, y: -590, radius: 18 });
					sleep(100).then(() => {
						game.rsCorner = true;
						game.outStatus = "blueCK";
						game.rsTimer = 0;
						game.rsReady = true;
						game.boosterCount = 0;
						game.boosterState = false;
						room.setDiscProperties(0, {x: -1140, y: -590, xspeed: 0, yspeed: 0, color: "0x0fbcf9", cMask: 268435519, xgravity: 0, ygravity: 0});
						room.setDiscProperties(1, {x: -1150, y: -670, radius: 420 });
						room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
					});	
				}
				if (room.getBallPosition().y > 124) {
					room.setDiscProperties(3, {x: -1140, y: 590, radius: 18 });
					sleep(100).then(() => {
						game.rsCorner = true;
						game.outStatus = "blueCK";
						game.rsTimer = 0;
						game.rsReady = true;
						game.boosterCount = 0;
						game.boosterState = false;
						room.setDiscProperties(0, {x: -1140, y: 590, xspeed: 0, yspeed: 0, color: "0x0fbcf9", cMask: 268435519, xgravity: 0, ygravity: 0});
						room.setDiscProperties(1, {x: -1150, y: 670, radius: 420 });
						room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
					});		
				}				
			}
			else {				
				room.setDiscProperties(3, {x: -1060, y: 0, radius: 18 });
				sleep(100).then(() => {
					game.outStatus = "redGK";
					game.rsTimer = 0;
					game.rsReady = true;
					//announce("ü•Ö Goal Kick: üî¥ Red");
					game.rsGoalKick = true;
					game.rsSwingTimer = 0;
					game.boosterCount = 0;
					game.boosterState = false;
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, x: -1060, y: 0, color: "0xff3f34", cMask: 268435519, xgravity: 0, ygravity: 0});
				});
				sleep(3000).then(() => {
					room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				});
			}
		}
	}
	
	if (game.rsActive == false && (game.outStatus == "redThrow" || game.outStatus == "blueThrow")) { 
		if ((room.getBallPosition().y > 611.45 || room.getBallPosition().y < -611.45) && (room.getBallPosition().x < game.ballOutPositionX - throwinDistance || room.getBallPosition().x > game.ballOutPositionX + throwinDistance) && game.bringThrowBack == false) { //if bad throw from run too far
			game.bringThrowBack	= true;
			if (game.outStatus == "redThrow") { //switch to blue throw
				game.rsTimer = 0;
				game.warningCount++;
				game.outStatus = "blueThrow";								
				room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				sleep(100).then(() => {
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, color: "0x0fbcf9", x: game.ballOutPositionX, y: game.throwInPosY});	
				});			
			}
			else if (game.outStatus == "blueThrow") { //switch to red throw
				game.rsTimer = 0;
				game.warningCount++;
				game.outStatus = "redThrow";										
				room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});	
				sleep(100).then(() => {
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, color: "0xff3f34", x: game.ballOutPositionX, y: game.throwInPosY});
				});
			}
				
		}
		
		if (room.getBallPosition().y < 611.45 && room.getBallPosition().y > -611.45 && game.throwinKicked == false && game.pushedOut == false) { //if bad throw from push ball back into active without kick		
			if (game.outStatus == "redThrow") { //switch to blue throw
				game.rsTimer = 0;
				game.warningCount++;
				game.outStatus = "blueThrow";								
				room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});
				sleep(100).then(() => {
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, color: "0x0fbcf9", x: game.ballOutPositionX, y: game.throwInPosY});
				});					
			}
			else if (game.outStatus == "blueThrow") { //switch to red throw
				game.rsTimer = 0;
				game.warningCount++;
				game.outStatus = "redThrow";										
				room.setDiscProperties(3, {x: 0, y: 2000, radius: 0});	
				sleep(100).then(() => {
					room.setDiscProperties(0, {xspeed: 0, yspeed: 0, color: "0xff3f34", x: game.ballOutPositionX, y: game.throwInPosY});
				});
			}
			game.pushedOut = true;
		}
		
		if (room.getBallPosition().y < 611.45 && room.getBallPosition().y > -611.45 && game.throwinKicked == true) { // if throw is good
			game.outStatus = "";
			game.rsActive = true;
			game.rsReady = false;
			room.setDiscProperties(0, {color: "0xffffff"});
			game.rsTimer = 1000000;
			game.warningCount++;
		}
		
		if (room.getBallPosition().y.toFixed(1) == game.throwInPosY.toFixed(1) && room.getBallPosition().x.toFixed(1) == game.ballOutPositionX.toFixed(1)) {
			game.bringThrowBack	= false;
			game.pushedOut = false;
		}
	}
}


function handleBallTouch() {
	var players = room.getPlayerList();
	var ballPosition = room.getBallPosition();
	var ballRadius = game.ballRadius;
	var playerRadius = 15;
	var triggerDistance = ballRadius + playerRadius + 0.01;
	
	for (var i = 0; i < players.length; i++) { // Iterate over all the players
		var player = players[i];
		if ( player.position == null ) continue;
		var distanceToBall = pointDistance(player.position, ballPosition);
		if ( distanceToBall < triggerDistance ) {				
			game.rsTouchTeam = player.team;
			game.throwinKicked = false;
			
			if (game.rsCorner == false && room.getDiscProperties(0).xgravity != 0) {
				room.setDiscProperties(0, {xgravity: 0, ygravity:0});
				game.rsSwingTimer = 10000;
			}
		}		
	}
}

function updateGameStatus() {
	game.time = Math.floor(room.getScores().time);
	game.ballRadius = room.getDiscProperties(0).radius;
}


function announce(msg, targetId, color, style, sound) {
	if (color == null) {
		color = COLOR_NORMAL;
	}
	if (style == null) {
		style = "bold";
	}
	if (sound == null) {
		sound = 3;
	}
	room.sendAnnouncement(msg, targetId, color, style, sound);
	console.log("Announce: " + msg);
}

function whisper(msg, targetId, color, style, sound) {
	if (color == null) {
		color = COLOR_INFO;
	}
	if (style == null) {
		style = "normal";
	}
	if (sound == null) {
		sound = 3;
	}
	room.sendAnnouncement(msg, targetId, color, style, sound);
	if (room.getPlayer(targetId) != null) {
		console.log("Whisper -> " + room.getPlayer(targetId).name + ": " + msg);
	}
}

function isAdminPresent() {
	var players = room.getPlayerList();
	if (players.find((player) => player.admin) != null) {
		return true;
	}
	else {
		return false;
	}
}

function displayAdminMessage() {
	if (isAdminPresent() == false && allowPublicAdmin == true) {
		announce("No admin present: Type !admin to take control");
	}
}

function pointDistance(p1, p2) {
	var d1 = p1.x - p2.x;
	var d2 = p1.y - p2.y;
	return Math.sqrt(d1 * d1 + d2 * d2);
}

function sleep (time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}

function ballWarning(origColour, warningCount) {
	sleep(200).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: "0xffffff"});
		}
	});
	sleep(400).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: origColour});
		}
	});
	sleep(600).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: "0xffffff"});
		}
	});
	sleep(800).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: origColour});
		}
	});
	sleep(1000).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: "0xffffff"});
		}
	});
	sleep(1200).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: origColour});
		}
	});
	sleep(1400).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: "0xffffff"});
		}
	});
	sleep(1600).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: origColour});
		}
	});
	sleep(1675).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: "0xffffff"});
		}
	});
	sleep(1750).then(() => {
		if (game.warningCount == warningCount) {
			room.setDiscProperties(0, {color: origColour});
		}
	});
}

function extraTime() {
	var extraSeconds = Math.ceil(game.extraTimeCount / 60);
	game.extraTimeEnd = (gameTime * 60) + extraSeconds;
	announce("Extra time: " + extraSeconds + " Seconds", null, null, null, 1);
}

function avatarCelebration(playerId, avatar) {
	room.setPlayerAvatar(playerId, avatar);
	sleep(250).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
	sleep(500).then(() => {
		room.setPlayerAvatar(playerId, avatar);
	});
	sleep(750).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
	sleep(1000).then(() => {
		room.setPlayerAvatar(playerId, avatar);
	});
	sleep(1250).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
	sleep(1500).then(() => {
		room.setPlayerAvatar(playerId, avatar);
	});
	sleep(1750).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
	sleep(2000).then(() => {
		room.setPlayerAvatar(playerId, avatar);
	});
	sleep(2250).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
	sleep(2500).then(() => {
		room.setPlayerAvatar(playerId, avatar);
	});
	sleep(2750).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
	sleep(3000).then(() => {
		room.setPlayerAvatar(playerId, avatar);
	});
	sleep(3250).then(() => {
		room.setPlayerAvatar(playerId, null);
	});
}

function secondsToMinutes(time) {
	// Hours, minutes and seconds
    var hrs = ~~(time / 3600);
    var mins = ~~((time % 3600) / 60);
    var secs = ~~time % 60;

    // Output like "1:01" or "4:03:59" or "123:03:59"
    var ret = "";
    if (hrs > 0) {
        ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
    }
    ret += "" + mins + ":" + (secs < 10 ? "0" : "");
    ret += "" + secs;
    return ret;
}

function blockThrowIn() {
	var players = room.getPlayerList().filter((player) => player.team != 0);
	if (room.getBallPosition().y < 0) { // top throw line
		if (game.outStatus == "redThrow") {
			players.forEach(function(player) {
				if (player.team == 2 && room.getPlayerDiscProperties(player.id).y < 0) {
					if (room.getPlayerDiscProperties(player.id).cGroup != 536870918) {
						room.setPlayerDiscProperties(player.id, {cGroup: 536870918});
					}
					if (player.position.y < -485) {
						room.setPlayerDiscProperties(player.id, {y: -470});
					}
				}
				if (player.team == 1 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
					room.setPlayerDiscProperties(player.id, {cGroup: 2});
				}
				if (room.getDiscProperties(17).x != 1149) { // show top red line
					room.setDiscProperties(17, {x: 1149});
				}
				if (room.getDiscProperties(19).x != -1149) { // hide top blue line
					room.setDiscProperties(19, {x: -1149});
				}
			});
		}
		if (game.outStatus == "blueThrow") {
			players.forEach(function(player) {
				if (player.team == 1 && room.getPlayerDiscProperties(player.id).y < 0) {
					if (room.getPlayerDiscProperties(player.id).cGroup != 536870918) {
						room.setPlayerDiscProperties(player.id, {cGroup: 536870918});
					}
					if (player.position.y < -485) {
						room.setPlayerDiscProperties(player.id, {y: -470});
					}
				}
				if (player.team == 2 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
					room.setPlayerDiscProperties(player.id, {cGroup: 2});
				}
				if (room.getDiscProperties(19).x != 1149) { // show top blue line
					room.setDiscProperties(19, {x: 1149});
				}
				if (room.getDiscProperties(17).x != -1149) { // hide top red line
					room.setDiscProperties(17, {x: -1149});
				}
			});
		}
	}
	if (room.getBallPosition().y > 0) { // bottom throw line
		if (game.outStatus == "redThrow") {
			players.forEach(function(player) {
				if (player.team == 2 && room.getPlayerDiscProperties(player.id).y > 0) {
					if (room.getPlayerDiscProperties(player.id).cGroup != 536870918) {
						room.setPlayerDiscProperties(player.id, {cGroup: 536870918});
					}
					if (player.position.y > 485) {
						room.setPlayerDiscProperties(player.id, {y: 470});
					}
				}
				if (player.team == 1 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
					room.setPlayerDiscProperties(player.id, {cGroup: 2});
				}
				if (room.getDiscProperties(21).x != 1149) { // show bottom red line
					room.setDiscProperties(21, {x: 1149});
				}
				if (room.getDiscProperties(23).x != -1149) { // hide bottom blue line
					room.setDiscProperties(23, {x: -1149});
				}
			});
		}
		if (game.outStatus == "blueThrow") {
			players.forEach(function(player) {
				if (player.team == 1 && room.getPlayerDiscProperties(player.id).y > 0) {
					if (room.getPlayerDiscProperties(player.id).cGroup != 536870918) {
						room.setPlayerDiscProperties(player.id, {cGroup: 536870918});
					}
					if (player.position.y > 485) {
						room.setPlayerDiscProperties(player.id, {y: 470});
					}
				}
				if (player.team == 2 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
					room.setPlayerDiscProperties(player.id, {cGroup: 2});
				}
				if (room.getDiscProperties(23).x != 1149) { // show bottom blue line
					room.setDiscProperties(23, {x: 1149});
				}
				if (room.getDiscProperties(21).x != -1149) { // hide bottom red line
					room.setDiscProperties(21, {x: -1149});
				}
			});
		}		
	}	
}


function blockGoalKick() {
	var players = room.getPlayerList().filter((player) => player.team != 0);
	if (room.getBallPosition().x < 0) { // left side red goal kick
		if (game.outStatus == "redGK") {
			players.forEach(function(player) {
				if (player.team == 2 && room.getPlayerDiscProperties(player.id).x < 0) {
					if (room.getPlayerDiscProperties(player.id).cGroup != 268435462) {
						room.setPlayerDiscProperties(player.id, {cGroup: 268435462});
					}
					if (player.position.x < -840 && player.position.y > -320 && player.position.y < 320) {
						room.setPlayerDiscProperties(player.id, {x: -825});
					}
				}
				if (player.team == 1 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
					room.setPlayerDiscProperties(player.id, {cGroup: 2});
				}
			});
		}
	}
	if (room.getBallPosition().x > 0) { // right side blue goal kick
		if (game.outStatus == "blueGK") {
			players.forEach(function(player) {
				if (player.team == 1 && room.getPlayerDiscProperties(player.id).x > 0) {
					if (room.getPlayerDiscProperties(player.id).cGroup != 268435462) {
						room.setPlayerDiscProperties(player.id, {cGroup: 268435462});
					}
					if (player.position.x > 840 && player.position.y > -320 && player.position.y < 320) {
						room.setPlayerDiscProperties(player.id, {x: 825});
					}
				}
				if (player.team == 2 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
					room.setPlayerDiscProperties(player.id, {cGroup: 2});
				}
			});
		}		
	}	
}



function removeBlock() {
	var players = room.getPlayerList().filter((player) => player.team != 0);
	if (game.outStatus == "") {
		players.forEach(function(player) {
			if (player.team == 1 && room.getPlayerDiscProperties(player.id).cGroup != 2) {
				room.setPlayerDiscProperties(player.id, {cGroup: 2});
			}
			if (player.team == 2 && room.getPlayerDiscProperties(player.id).cGroup != 4) {
				room.setPlayerDiscProperties(player.id, {cGroup: 4});
			}
		});
		if (room.getDiscProperties(17).x != -1149) { // hide top red line
			room.setDiscProperties(17, {x: -1149});
		}
		if (room.getDiscProperties(19).x != -1149) { // hide top blue line
			room.setDiscProperties(19, {x: -1149});
		}
		if (room.getDiscProperties(21).x != -1149) { // hide bottom red line
			room.setDiscProperties(21, {x: -1149});
		}
		if (room.getDiscProperties(23).x != -1149) { // hide bottom blue line
			room.setDiscProperties(23, {x: -1149});
		}		
	}
}

// Fun√ß√£o para obter os bans atuais do HaxBall e sincronizar com o nosso sistema
function syncBans() {
    // Obt√©m a lista de bans do HaxBall (precisamos simular, j√° que n√£o temos acesso direto)
    let currentBans = [];
    
    // Remove os banimentos que n√£o existem mais no HaxBall
    bannedPlayers = bannedPlayers.filter(ban => {
        // Verificamos se o banimento ainda existe (simula√ß√£o)
        return currentBans.some(currentBan => currentBan.ip === ban.ip);
    });
}

// Fun√ß√£o para formatar a data do banimento
function formatBanDate(date) {
    return date.toLocaleDateString() + " " + date.toLocaleTimeString();
}

// Fun√ß√£o para desbanir um jogador espec√≠fico
function unbanPlayer(index) {
    if (index < 0 || index >= bannedPlayers.length) {
        return false;
    }
    
    let playerToUnban = bannedPlayers[index];
    
    // Tentamos desbanir o jogador via HaxBall API
    // HaxBall n√£o tem m√©todo para desbanir individualmente, ent√£o precisamos usar um workaround
    let tempBans = [];
    
    // 1. Primeiro, armazenamos todos os bans atuais temporariamente
    room.getPlayerList().forEach(p => {
        // Armazenamos o conn do jogador atual, se ele n√£o for o que queremos desbanir
        if (p.conn !== playerToUnban.ip) {
            tempBans.push(p.conn);
        }
    });
    
    // 2. Limpamos todos os bans
    room.clearBans();
    
    // 3. Re-banimos todos exceto o que queremos desbanir
    tempBans.forEach(conn => {
        // Aqui precisar√≠amos re-banir, mas n√£o temos uma API direta para isso
        // Este √© um ponto problem√°tico na implementa√ß√£o
        // room.banPlayer(conn); // Isto n√£o existe na API do HaxBall
    });
    
    // 4. Removemos o banimento da nossa lista
    bannedPlayers.splice(index, 1);
    
    return true;
}

// Fun√ß√£o para detectar goleiros (mantida apenas por compatibilidade, n√£o √© mais usada diretamente)
function detectGoalkeepers() {
    console.log("AVISO: A fun√ß√£o detectGoalkeepers() n√£o √© mais usada diretamente.");
    return; // Esta fun√ß√£o foi integrada diretamente em attemptGoalkeeperDetection
}

// Fun√ß√£o para determinar o rank do jogador baseado em suas estat√≠sticas
function getPlayerRank(stats) {
    // C√°lculo de pontua√ß√£o baseado nas estat√≠sticas
    let rating = 0;
    
    // Verifica se o jogador tem VIP para b√¥nus de pontos
    let vipBonus = 1.0; // Sem b√¥nus por padr√£o
    
    // Se o jogador tem registro, verifica seu status VIP
    if (stats._conn && registeredUsers[stats._conn] && registeredUsers[stats._conn].vip) {
        vipBonus = registeredUsers[stats._conn].vip === "plus" ? VIP_TYPES.PLUS.rankBonus : VIP_TYPES.BASIC.rankBonus;
    }
    
    // Pontos por vit√≥ria
    rating += stats.wins * 10 * vipBonus;
    
    // Pontos por gol
    rating += stats.goals * 5 * vipBonus;
    
    // Pontos por assist√™ncia
    rating += stats.assists * 3 * vipBonus;
    
    // B√¥nus por clean sheets para goleiros
    if (stats.isGoalkeeper) {
        rating += stats.cleanSheets * 7 * vipBonus;
    }
    
    // Penalidade por gols contra
    rating -= stats.ownGoals * 2;
    
    // Encontra o rank correspondente √† pontua√ß√£o
    let playerRank;
    if (rating >= RANKS.RADIANT.minRating) playerRank = RANKS.RADIANT;
    else if (rating >= RANKS.MASTER.minRating) playerRank = RANKS.MASTER;
    else if (rating >= RANKS.DIAMOND.minRating) playerRank = RANKS.DIAMOND;
    else if (rating >= RANKS.GOLD.minRating) playerRank = RANKS.GOLD;
    else if (rating >= RANKS.SILVER.minRating) playerRank = RANKS.SILVER;
    else playerRank = RANKS.BRONZE;
    
    // Retorna o rank e a pontua√ß√£o atual
    return {
        ...playerRank,
        rating: Math.floor(rating)
    };
}

// ... existing code ...

// Armazena refer√™ncia do conn nas estat√≠sticas para identifica√ß√£o de VIP
function updatePlayerStats() {
    console.log("Atualizando estat√≠sticas de jogadores...");
    
    // Obt√©m jogadores dos times
    let players = room.getPlayerList();
    let redPlayers = players.filter(p => p.team === 1);
    let bluePlayers = players.filter(p => p.team === 2);
    
    // Determina o time vencedor
    let winningTeam = game.redScore > game.blueScore ? 1 : 2;
    let losingTeam = winningTeam === 1 ? 2 : 1;
    
    // An√∫ncio sobre atualiza√ß√µes de estat√≠sticas
    announce("üìä Atualizando estat√≠sticas dos jogadores...", null, COLOR_SUCCESS, "bold");
    
    // Contadores para log
    let playersUpdated = 0;
    let playersSkipped = 0;
    
    // Todos os jogadores (tanto os em jogo quanto os que possam ter sa√≠do)
    let allRedAndBluePlayers = [...redPlayers, ...bluePlayers];
    
    // Se temos muito poucos jogadores, podemos ter perdido alguns que sa√≠ram recentemente
    if (allRedAndBluePlayers.length < 2) {
        console.log("AVISO: Poucos jogadores para atualizar estat√≠sticas. Alguns podem ter sa√≠do.");
    }
    
    console.log(`Atualizando estat√≠sticas para ${allRedAndBluePlayers.length} jogadores`);
    
    // Atualiza estat√≠sticas para cada jogador
    for (let player of allRedAndBluePlayers) {
        let conn = playerConn[player.id];
        if (!conn || !registeredUsers[conn]) {
            console.log(`Jogador ${player.name} n√£o tem conn v√°lido ou n√£o est√° registrado`);
            playersSkipped++;
            continue;
        }
        
        console.log(`Atualizando estat√≠sticas para ${player.name}`);
        
        // Incrementa jogos jogados
        registeredUsers[conn].stats.games++;
        
        // Registra vit√≥ria ou derrota
        if (player.team === winningTeam) {
            registeredUsers[conn].stats.wins++;
            console.log(`${player.name} ganhou - wins: ${registeredUsers[conn].stats.wins}`);
        } else if (player.team === losingTeam) {
            registeredUsers[conn].stats.losses++;
            console.log(`${player.name} perdeu - losses: ${registeredUsers[conn].stats.losses}`);
        }
        
        // Verifica clean sheet para goleiros
        if (player.team === 1 && player.id === currentGoalkeepers.red && cleanSheetEligible.red) {
            if (game.blueScore === 0) {
                registeredUsers[conn].stats.cleanSheets++;
                announce("üß§ Clean Sheet para " + player.name + "! | Defesa perfeita!", null, COLOR_RED, "bold");
                console.log(`${player.name} conseguiu um Clean Sheet!`);
            }
        } else if (player.team === 2 && player.id === currentGoalkeepers.blue && cleanSheetEligible.blue) {
            if (game.redScore === 0) {
                registeredUsers[conn].stats.cleanSheets++;
                announce("üß§ Clean Sheet para " + player.name + "! | Defesa perfeita!", null, COLOR_BLUE, "bold");
                console.log(`${player.name} conseguiu um Clean Sheet!`);
            }
        }
        
        // Resetamos a flag de goleiro no final do jogo
        registeredUsers[conn].stats.isGoalkeeper = false;
        
        // Adiciona refer√™ncia de conn para verifica√ß√£o de VIP
        registeredUsers[conn].stats._conn = conn;
        
        // Log das estat√≠sticas atualizadas
        console.log(`Estat√≠sticas de ${player.name} ap√≥s atualiza√ß√£o: Jogos=${registeredUsers[conn].stats.games}, Vit√≥rias=${registeredUsers[conn].stats.wins}, Derrotas=${registeredUsers[conn].stats.losses}, CS=${registeredUsers[conn].stats.cleanSheets}`);
        
        playersUpdated++;
    }
    
    console.log(`Atualiza√ß√£o de estat√≠sticas conclu√≠da: ${playersUpdated} jogadores atualizados, ${playersSkipped} ignorados`);
    announce(`‚úÖ Estat√≠sticas atualizadas para ${playersUpdated} jogadores`, null, COLOR_SUCCESS, "bold");
}




